% TEMPLATE for Usenix papers, specifically to meet requirements of
%  USENIX '05
% originally a template for producing IEEE-format articles using LaTeX.
%   written by Matthew Ward, CS Department, Worcester Polytechnic Institute.
% adapted by David Beazley for his excellent SWIG paper in Proceedings,
%   Tcl 96
% turned into a smartass generic template by De Clarke, with thanks to
%   both the above pioneers
% use at your own risk.  Complaints to /dev/null.
% make it two column with no page numbering, default is 10 point

% Munged by Fred Douglis <douglis@research.att.com> 10/97 to separate
% the .sty file from the LaTeX source template, so that people can
% more easily include the .sty file into an existing document.  Also
% changed to more closely follow the style guidelines as represented
% by the Word sample file. 

% Note that since 2010, USENIX does not require endnotes. If you want
% foot of page notes, don't include the endnotes package in the 
% usepackage command, below.

%----------------------------------------------------------------------------------------
%	PACKAGES & CONFIG
%----------------------------------------------------------------------------------------

%\documentclass[paper=a4, fontsize=11pt]{article} % A4 paper and 11pt font size
\documentclass[letterpaper,twocolumn,10pt]{article}

\usepackage{usenix,epsfig,endnotes}
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{listings} % source code package
\usepackage{tikz} % graph package
\usepackage{supertabular} % table span multiple pages
\usetikzlibrary{shapes,arrows}
\usepackage{courier}

%\usepackage{sectsty} % Allows customizing section commands
%\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps
%\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\begin{document}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Analisys and Verification of Program Project 2014}

\author{
{\rm Gianluca Barbon}\\
gbarbon@dsi.unive.it
\and
{\rm Cristian De Zotti}\\
cdezotti@dsi.unive.it
\and
{\rm Marco Moscardo}\\
mmoscardo@dsi.unive.it
}
\date{July 1, 2014}
\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}


\subsection*{Abstract}
Your Abstract Text Goes Here.  Just a few facts.
Whet our appetites.


%----------------------------------------------------------------------------------------
%	1. Introduction
%----------------------------------------------------------------------------------------

\section{Introduction}
\paragraph{}
The aim of this analysis is to verify if the application variables contain confidential data, as a result of the use of certain methods that they have saved their results.  
In this paper we purpose an analysis to find all variables which are classified as potential exported variables using the notion of Class Control Flow Graph.
First of all we explain the idea of this analysis applying it to simplified object oriented programs and then using it to extended object oriented language which are the same of the language used by the Android platform.
Note: we use the abbreviation \lq\lq confidential methods \rq\rq for methods that generate data containing confidential information and \lq\lq confidential data \rq\rq to indicate the data generated by confidatial methods. We use the verb \lq\lq export \rq\rq to indicate all the possible ways to save/export confidential data.
Now the main question becomes: in an application that generates sensitive data, these data are exported?
\subsection{Data Definition}
\paragraph{}
Data can be classified in three different classes: \textit{personal, confidential or sensitive.} The main difference between these types of data is the kind of information which are related. 

\textbf{Personal data} is '\emph{data which relates to a living individual who can be identified from those data OR from those data and other information which is in the possession of or is likely to come into the possession of the data controller (e.g. University) and includes any expression of opinion about the individual}' - Data Protection Act (1998).

\textbf{Confidential data} is data that can be connected to the person providing them or that could lead to the identification of a person referred to, such as names, address, etc. This information, which are not in the public domain, are given in confidence, or with data agreed to be kept '\textit{confidential}' (namely secret) between two parties. 

\textbf{Sensitive data} is '\emph{data on a person's race, ethnic origin, political opinion, religious or similar beliefs, trade union membership, physical or mental health or condition, sexual life, commission or alleged commission of an offence, proceedings for an offence (alleged to have been) committed, disposal of such proceedings or the sentence of any court in such proceedings} - Data Protection Act (1998)

In this paper we are only focused on the confidential data that is the most exported data without authorization.

%----------------------------------------------------------------------------------------
%	2. Safeness Analysis Formal Definition
%----------------------------------------------------------------------------------------

\section{Safeness Analysis Formal Definition}
\paragraph{}
Our analysis will be based on the Data Flow analysis techniques, and will be named \emph{Safeness Analysis}. As said before, it will identify exported elements that contains confidential data. This analysis will determine exported and possibly confidential variables at the entry and exit point of each node. We will consider the collection of values composed of $\{x, x[y, z, \ldots], n\}$ where \emph{x} is the exported variable, [\emph{y,z,...}] is the chain of variables used in the definition of \emph{x} and \emph{n} is the involved node. Moreover, we will consider $\{x, y, n\}$ as the variable \emph{x} equal to \emph{y} in node \emph{n}. Please notice that this last statement has different meanings depending on the fact that the variable consist in an object or in a primitive element, but we will see this later in a more precise way.\\

Thus, variable \emph{x} and its chain are exported and potentially confidential if:
\begin{itemize}\itemsep2pt \parskip0pt \parsep0pt
\item a path \emph{p} from \emph{n} to \emph{m} exists
\item variable \emph{x} is exported and potentially\\ confidential in \emph{n}
\item variable \emph{x} is never re-defined in \emph{p}
\end{itemize}

We have to consider that our \emph{Safeness Analysis} is taking place in an Object Oriented environment. Anyway, we will deal later with complex concepts from O. O. programming, like interfaces and interfaces. On the other hand, we will first start from a simple pseudo-code version of an object oriented programming paradigm. That's to say, an o.o. programming language similar to Java that will use only classes, methods and creators, in order to ``make it simple''.

\subsection{Gen/Kill}
\paragraph{}
Let's consider operations that generate and kill information:
\begin{align*}
\begin{tabular}{  l l }
	$ gen_{SA}[\text{B}]= $ & $ \{ element\ is\ exported \} $\\ 
	& \\                  
	$  kill_{SA}[\text{B}]= $ & $ \{ element\ is\ not\ created\ by\ a\ $\\ 
	& $\ confidential\ method \} $ \\
\end{tabular}
\end{align*}

A more precise definition of \emph{gen} and \emph{kill} could be made considering also variable that are not exported directly, but are used in the definition of exported variable. But we decided to have simple \emph{gen} and \emph{kill} definition, and to improve it later for specific cases (please refer to section 2.3).\\
%We can expand \emph{gen} and \emph{kill} definition:\\
%\begin{align*}
%\begin{tabular}{  l l }
%	$ gen_{SA}[\text{B}]= $ & $ \{ var\ x\ is\ exported $\\ 
%	& OR \\
%	& $ var\ x\ is\ used\ by\ an\ exported\ variable\ y\ $\\ 
%	& $ ( so\ x\ is\ added\ in\ the\ chain\ of\ y ) \} $ \\
%	& \\                  
%	$  kill_{SA}[\text{B}]= $ & $ \{ var\ x\ is\ not\ created\ by\ a\ sensible\ method\ $\\
%    & OR \\ 
%    & $ chain\ of\ var\ x\ contains\ only\ variables\ $ \\
%    & $ that\ are\ not\ sensible\ \} $ \\
%\end{tabular}
%\end{align*}

\indent
In order to collect only variables that are exported, our analysis will start from the end of the program. Thus, it will be a \emph{Backward Analysis}. This behaviour is similar to the \emph{Live Variables Analysis}~\cite{Nielson:1999:PPA:555142} one. We can now specify the features of our analysis. 
\begin{description}
\item[\textbf{Analysis direction:}] backward
\item[\textbf{Confluence operator: }] union\\ $ \text{out}[B]\ =\ \cup\ \text{in}[S],\ over\ the\ successor\ S\ of\ B\  $
\item[\textbf{Initialization: }] empty set, \quad $ \emptyset $
\end{description}

It is now possible to define the equations of the analysis.
\subsection{Safeness Analysis equations}
\begin{gather*}
SA_\textrm{$exit$}(p)\ =\ 
\begin{cases}
\emptyset\qquad if\ p\ is\ a\ final\ point\ \\ \\
\cup\ \lbrace SA_\textrm{$entry$}(q)\ |\ q\ follows\ p\ in\ the\ CFG \rbrace 
\end{cases} \\ \\
SA_\textrm{$entry$}(p)\ =\ \text{gen}_\textrm{SA}(p)\ \cup\ (SA_\textrm{$exit$}(p)\ \textbackslash\ \text{kill}_\textrm{SA}(p)\ )
\end{gather*}

At the end of the analysis we will have two possible states:
\begin{itemize}
\item no more variables collected in our tables
\item some variables are still present in our tables
\end{itemize}
The first state means that the examined program is \emph{SAFE}. Indeed, if no variables are present in our analysis memory, all the variables considered possibly unsafe have been removed because they are certified as non confidential data.\\
On the other side, the second state means that the program is \emph{UNSAFE}. This is due to the fact that some variables remains in our analysis memory, confirming that these variables contain confidential data. Thus, our analysis is also capable of locating unsafe variables.

\subsection{Difference between objects and primitive data types}
\paragraph{}
The definitions given so far are not sufficient to describe our analysis. Indeed \emph{gen} and \emph{kill} are more complicated. We have to deal with different problems related to the object oriented paradigm. First of all, we have to consider that also variables used in the definition of elements that will be exported may contain confidential data. So a complete analysis has to consider also these variables.
Second, it is important to divide variables into two subsets:
\begin{itemize}
\item primitive variables
\item objects
\end{itemize}
This necessary distinction comes from various assumptions. Firs of all, in an object oriented programming language objects are passed by reference, while primitive variables are passed by copy. In example, in Java a variable that uses a class as type does not actually contain an object of that class. Instead, it only stores the position of the object in the system memory ~\cite{Horstmann:2008:BJ:1796502}. So we present the different cases in a more precise way.

\noindent \paragraph{Primitive Variables}
\begin{description}

\item[\texttt{export(x)}] \hfill \\
Variable \emph{x} is exported with a method. In this case the \emph{gen} step will add the record $\{x, n\}$ in the table into the \emph{gen} column.

\item[\texttt{x = y}] \hfill \\
The variable is copied from another one, and we know that it will be exported (notice that, in order to make this \emph{gen} step sound, we also have to know that variable \emph{x} will not change its value in the path between the copy and the exportation points). In this case the \emph{gen} step will add the record $\{x, y, n\}$ in the table into the \emph{gen} column. A later \emph{kill} (going backward after this statement) of the copied variable \emph{y} will remove the information added with this \emph{gen} step, and also the information related to the exportation of the \emph{x} variable.

\item[\texttt{x = method(y)}] \hfill \\
The variable is used in the creation of another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, x[y], n\}$ in the table into the \emph{gen} column. If the primitive variables involved as parameter are more than one, we will have a record like this: $\{x, x[y,x,...], n\}$.  A later \emph{kill} of the referred variable \emph{y} will remove the information added with this \emph{gen} step, but will not delete the information related to the exportation of the first variable \emph{x}. This is because, even if \emph{y} variable is \emph{SAFE}, the method that generates the first one may make use of confidential information, like other methods or variables belonging to its class, and so we cannot trust variable \emph{x}. In order to check the safeness of variable \emph{x}, we must expand the \emph{CFG} of this method.

\item[\texttt{x = method()}] \hfill \\
The variable \emph{x} is generated. If, by expanding and inspecting the \emph{CFG} of this method, we find out (or we already know) that it's \emph{not confidential}, we can perform a \emph{kill} step. Otherwise, no steps are performed.

\end{description}

\noindent \paragraph{Objects}
\begin{description}
\item[\texttt{x.export()}] \hfill \\
Object \emph{x} is exported with a method. In this case the \emph{gen} step will add the record $\{x, n\}$ in the table into the \emph{gen} column.

\item[\texttt{CClass x = y}] \hfill \\
The object is referred from another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, y, n\}$ in the table into the \emph{gen} column. A later \emph{kill} of the referred object (\emph{y}) will remove the information added with this \emph{gen} step, and also the information related to the exportation of the first object (\emph{x}).

\item[\texttt{CClass x = new CClass(y)}] \hfill \\
The object is used in the creation of another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, x[y], n\}$ in the table into the \emph{gen} column. A later \emph{kill} of the referred object \emph{y} will remove the information added with this \emph{gen} step, but will not delete the information related to the exportation of the first object (\emph{x}). This is because, even if \emph{y} object is \emph{SAFE}, the creator of the first one may make use of confidential information, and so we cannot trust the \emph{x} object. In order to check the safeness of the \emph{x} object, we must expand the \emph{CFG} of its constructor.

\item[\texttt{CClass x = new CClass()}] \hfill \\
The object \emph{x} is created. We cannot make any \emph{kill} step, because we don't know if the constructor of this object is \emph{SAFE}. As said for the previous case, we must expand and inspect its \emph{CFG}.
\end{description}

As we have just seen, primitive variables and objects have different behaviour in the \emph{gen} and \emph{kill} steps. Anyway, the syntax used in the tables of the analysis is quite similar. Furthermore, it's important to remark that a class may declare confidential variables, anyway if we don't have methods that export these variables, the object is \emph{SAFE}. More precisely, objects may contain methods that exports confidential data, but if these methods are not used in the analysed application, these objects can be considered \emph{SAFE}. 

\subsection{CCFG: Class Control Flow Graph~\cite{CCFG}}
\paragraph{}
For the construction of our Control Flow Graph, we must use a different technique in object-oriented language with respect to an imperative language. This is due to the fact that in the object-oriented language is the ability to use multiple classes within the same application, and then with our graph must be able to represent the application in its entirety, including the relationship between the various classes given by method calls.\\
Has been developed an algorithm that allows the construction of CCFG of application, considering also the relationships between the various classes. The algorithm consists of four steps:
\begin{itemize}
\item The first step is to create the CFG of the class in question. 
\item In the second step, however, for each method inside the class, the class of the method is added to ours, and we are replacing the node that contains the method invocation, with the corresponding CFG. This operation continues until they were covered all the methods contained within the application, including those present in the interior of the classes that are added in the course of work.  
\item In the third step is made the update of the various edges of CCFG so that they are connected in an appropriate manner on all sides.
\item In the fourth step, the final, once finished all the above steps, it returns the CCFG application.
\end{itemize}

\subsubsection{CCFG Constructor Algorithm}
\lstset{basicstyle=\small\ttfamily, tabsize=2}
\begin{lstlisting}
algorithm: ConstructorCCFG(C):G
input: C a class
output: G a CCFG of C

begin ConstructCCFG
	
	/* Step1: Construct the class call 
	graph for the class C*/ 
	 G = Construct the CFG of C
	  
	/* Step2: Replace each call graph node 
	with the corresponding CFG */
	 foreach method M in C do
	  Add M class to C	  
	  Replace M node in G with CFG of M class

	/* Step3: Connect every individual 
	CFG */
	 Update edges appropriately 

	/* Step4: Return the completed 
	CCFG of G */
	 return G

end ConstructCCFG
\end{lstlisting}

\subsection{Safeness Analysis Algorithm}
\paragraph{}
The following shows the algorithm used to make the safeness analisys, which was derived from the equations introduced in Section 2.2:
\begin{tabbing}
% fissiamo le posizioni dei tab
~ \hspace{0.2cm} \= ~ \hspace{0.4cm} \= ~ \hspace{0.6cm} \= \\
for each n\\
\> in[n]:={ }; out[n]:={ };\\
repeat\\
\> for each n\\
\>\> in'[n]:= in[n]; out'[n]:= out[n];\\
\>\> in[n]:= use[n] $\cup$ (out[n]-def[n]);\\
\>\> out[n]:= $\cup${in[m] | m $\in$ succ[n]};\\
until(for each n: in'[n]= in[n] \&\& out'[n]= out[n])
\end{tabbing}    
        



%----------------------------------------------------------------------------------------
%	3. Examples
%----------------------------------------------------------------------------------------

\section{Examples}
\paragraph{}
We now apply our analysis to some examples written with the proposed simple version of an object oriented programming language.

\subsection{Example 1}
\paragraph{}
In this example we will see a very simple application that uses two class.
\subsubsection{Code}

\begin{verbatim}
. class MClass{
.
1     void main (String[] args) {	    
2         Text t	 = new Text("Hello!");
3         exportMethod(t);
.     }
.
4     void exportMethod(Text t) {        
5         ...
.         //this method exports 
.         //confidential values
.     }
. }
\end{verbatim}

\noindent We now have to consider Text class:
\begin{verbatim}
. class Text {
1     string s;
.	
2     Text(string b) { 	//constructor
3         string c	 = confidentialMethod();
4         this.s = b;
5         this.s = this.s + c;
.     }
.	
6     string confidentialMethod(){ 
.         //method with confidential values
7         string confidentialVariable;		
8         return confidentialVariable;
.     }
. }
\end{verbatim}

%\subsection{Dumb example}
%{\tt \small
%\begin{verbatim}
%...
%Text t	= new Text(confidentialText);
%...
%\end{verbatim}
%}
%But we also need to consider Text class: \\
%
%\begin{verbatim}
%class Text {
%    string s;	//class variable
%	
%    Text(string b) { 	//constructor
%        this.s = b;
%    }
%}
%\end{verbatim}
%
%In this example it is easy to see that the object t contains confidential datas.\\

\subsubsection{Description}
\paragraph{}
By only looking at \emph{MClass} object \emph{t} seems to be not confidential. Anyway, we must investigate also \emph{Text} class, because the constructor may contains methods that create confidential data in the new object. In order to do this, we can expand the CCFG of the \emph{text} constructor. In this way, we will see that the constructor makes use of \emph{ConfidentialMethod}, a method that generates confidential data. So, the object \emph{t} will be considered \emph{UNSAFE} and consequently also the application will be believed as \emph{UNSAFE}.

\subsubsection{CCFG}

% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define block styles
\tikzstyle{block} = [rectangle, draw, align=left]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{every node}=[font=\footnotesize]
\scalebox{0.85}{
\begin{tikzpicture}[node distance = 2cm, auto][every node/.style={inner sep=0,outer sep=0}]
    % Place nodes
    \node [block] (MC1) {void main (String[] args) \{ \\    Text t = new Text("Hello!");\\     exportMethod(t);\\ \} };
    \node [block, below of=MC1] (MC2){void exportMethod(Text t) \{ \\ ... \\ \} };
    \node [block, right of=MC2, node distance=5cm] (T1) {Text(string b) \{\\ string c = confidentialMethod(); \\ this.s = b; \\ this.s = this.s + c; \\ \} };
    \node [block, below of=T1] (T2) {string confidentialMethod()\{ \\ string confidentialVariable; \\ return confidentialVariable;\\ \} };
    
    % Draw edges
    \path [line] (MC1) -- (MC2);
    \path [line] (T1) -- (T2);
    
    %class labels
    \path (MC2.south)+(-0.4,-0.4) node (MClass) {MClass Class};
    \path (T2.south)+(-0.4,-0.4) node (Text) {Text Class};

    %background shapes 
    \begin{pgfonlayer}{background}
        %MClass class
        \path (MC1.west |- MC1.north)+(-0.2,0.2) node (a) {};
        \path (MC2.south -| MC1.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
        %Text class                
        \path (T1.west |- T1.north)+(-0.2,0.2) node (a) {};
        \path (T2.south -| T1.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
    \end{pgfonlayer}   
    
    %curved arrows
    \begin{scope}[looseness=1.6]
        \path [draw, ->] (MC1) edge[out=0,in=90,->]  node [right] {} (T1);
        \path [draw, ->] (T1) edge[out=180,in=0,->]  node [right] {} (MC1);
        %\path [draw, ->] (T2) edge[out=270,in=0,->]  node [right] {} (T1);
        %\path [draw, ->] (MC1) edge[out=270,in=180,->]  node [right] {} (MC1);
    \end{scope} 
    
\end{tikzpicture}
}

\subsubsection{Tables}
\begin{center}
\begin{supertabular}{|l|*{3}{c|}}
  \hline
  n & classname & gen & kill  \\
  \hline 
  3 & MClass & \{t,,3, MClass\} & \\ 
  2 & MClass & - & - \\
  5 & Text & \{t,t[c],5, Text\} & \\
  4 & Text & \{t,t[c,b],4, Text\} & \\
  3 & Text & - & - \\
  8 & Text &  & \\
  7 & Text &  & \\
  6 & Text &  & \\
  3 & Text &  & \\
  2 & Text &  & \\
  2 & MClass &  & \{b,2,MClass\}\\
  1 & MClass &  & \\
  \hline
\end{supertabular}
\end{center}
\begin{center}
\begin{supertabular}{|l|*{3}{c|}}
  \hline
  n & classname & entry & exit  \\
  \hline 
  3 & MClass & \{t\} &  \\ 
  2 & MClass & - & -\\
  5 & Text & \{t, c\} & \{t\} \\
  4 & Text & \{t, c, b\} & \{t, c\} \\
  3 & Text & - & - \\
  8 & Text & \{t, c, b\} & \{t, c, b\}    \\
  7 & Text & \{t, c, b\} & \{t, c, b\}    \\
  6 & Text & \{t, c, b\} & \{t, c, b\}    \\
  3 & Text & \{t, c, b\} & \{t, c, b\}    \\
  2 & Text & \{t, c, b\} & \{t, c, b\}    \\
  2 & MClass & \{t, c\} & \{t, c, b\}    \\
  1 & MClass & \{t, c\} & \{t, c\}    \\
  \hline
\end{supertabular}
\end{center}


\subsection{Example 2}

\subsubsection{Code}
\begin{verbatim}
1    CustomClass x = new CustomClass();
2    CustomClass y = x;
3    y.export();
\end{verbatim}

\subsubsection{Description}
\paragraph{}
This example has been created in order to show how important can be a Class Constructor in considering a variable confidential or not. We first notice that we can have various possibilities when creating a new object:
\begin{itemize}
  \item constructor doesn't make use of confidential data
  \item constructor USES confidential data
  \item parameters used in the constructor invocation contain confidential data
\end{itemize}

If we apply our analysis to this example, we will have the following steps:

\begin{enumerate}
\item gen step for object y (with export method)
\item object y results as a reference to x, so also x is added in the table
\item the kill step of x and y depends on the results of the analysis of the constructor method and of the CustomClass class (notice that variables declared in the class may be obtained as results of confidential methods)
\end{enumerate}

We can see that it is important to expand completely a CCFG in order to discover all the interesting path. So, by expanding the CCFG of \emph{CustomClass} we can have two cases:
\begin{itemize}
  \item constructor USES confidential data, so variables \emph{x} and \emph{y} cannot be killed, thus the application is \emph{UNSAFE}
  \item constructor doesn't make use of confidential data, so variables \emph{x} and \emph{y} are  both killed and the application is \emph{SAFE}
\end{itemize}

\subsubsection{CCFG}
%% Define block styles
%\tikzstyle{decision} = [diamond, draw, 
%    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
%\tikzstyle{block} = [rectangle, draw, 
%    text width=15em, text centered, rounded corners, minimum height=4em]
%\tikzstyle{line} = [draw, -latex']
%\tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
%    minimum height=2em]
%\begin{center}
%\begin{tikzpicture}[node distance = 2cm, auto]
%    % Place nodes
%    \node [block] (init) {CustomClass x = new CustomClass;};
%    \node [block, below of=init] (2){CustomClass y = x;};
%    \node [block, below of=2] (3) {y.export;};
%
%    % Draw edges
%    \path [line] (init) -- (2);
%    \path [line] (2) -- (3);
%\end{tikzpicture}
%\end{center}

% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define block styles
\tikzstyle{block} = [rectangle, draw, align=left]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{every node}=[font=\footnotesize]
\scalebox{0.85}{
\begin{tikzpicture}[node distance = 1cm, auto][every node/.style={inner sep=0,outer sep=0}]
    % Place nodes
    \node [block] (1) {CustomClass x = new CustomClass;};
    \node [block, below of=1] (2){CustomClass y = x;};
    \node [block, below of=2] (3) {y.export;};
    \node [below of=3, node distance = 2em] (dummy) {. . .};
    \node [below of=dummy, node distance = 2em] (method) {void export() \{...\}};
    \node [right of=2, node distance = 4cm] (CC) {CustomClass} edge[out=90,in=0,<-] (1.east); 
    \node [below of=CC, node distance = 2em] (dummy2) {. . .};
    
    % Draw edges
    \path [line] (1) -- (2);
    \path [line] (2) -- (3);
    
    %class labels
    \path (method.south)+(-0.8,-0.4) node (Class) {Main Class};
    %\path (dummy2.south)+(-0.4,-0.4) node (CClass) {CustomClass};

    %background shapes 
    \begin{pgfonlayer}{background}
        %Main Class
        \path (1.west |- 1.north)+(-0.2,0.2) node (a) {};
        \path (method.south -| 1.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
        %CustomClass
        \path (CC.west |- CC.north)+(-0.2,0.2) node (a) {};
        \path (dummy2.south -| CC.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
    \end{pgfonlayer}   
    
    %curved arrows
    \begin{scope}[looseness=1.6]
        \path [draw, ->] (3) edge[out=180,in=180,->]  node [right] {} (method);
    \end{scope} 
    
\end{tikzpicture}
}

\subsubsection{Tables}
We present here two possible version of tables. The first one show the case in which the constructor is \emph{UNSAFE}.
\begin{align*}
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & gen & kill  \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \\
  1 &  & \{x\} \\
  \hline
\end{tabular}
\qquad
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & entry & exit \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \{y \}\\
  1 & \{y, x\} & \{y, x\} \\
  \hline
\end{tabular}
\end{align*}

While the second one show the case in which the constructor is \emph{SAFE}. As we can see in the tables below, the variables under suspicion are killed and the application is considered \emph{SAFE}.
\begin{align*}
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & gen & kill  \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \\
  1 &  & \{x, y\} \\
  \hline
\end{tabular}
\qquad
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & entry & exit \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \{y \}\\
  1 &  & \{y, x\} \\
  \hline
\end{tabular}
\end{align*}

%----------------------------------------------------------------------------------------
%	4. Issues with a real Object Oriented Language
%----------------------------------------------------------------------------------------

\section{Issues with a real Object Oriented Language}
\paragraph{}
This section will explore some specific features of the object oriented programming languages applied to our analysis, in order to see whether it works or it should be expanded. When necessary and possible, we propose a solution to extend the analysis to these feature. Descriptions may make use of examples with the basic pseudocode already used in section 3, expanded with the required object oriented features.

\subsection{Interfaces} \paragraph{}
\subsubsection{Polymorphism} \paragraph{}
\subsubsection{Overloading} \paragraph{}
\subsubsection{Internal Classes} \paragraph{}

\subsection{Inheritance} \paragraph{}
\subsubsection{Polymorphism} \paragraph{}
\subsubsection{Overriding} \paragraph{}

\subsection{Recursion}
\paragraph{}
The recursion are used when we can see that our problem can be reduced to a simpler problem that can be solved after further reduction.

Every recursion should have the following characteristics.

\begin{itemize}
\item A simple base case which we have a solution for and a return value.
\item A way of getting our problem closer to the base case. I.e. a way to chop out part of the problem to get a somewhat simpler problem.
\item A recursive call which passes the simpler problem back into the method. 
\end{itemize}

Example:
\begin{verbatim}
void myMethod(int counter)
{
if(counter == 0)
     return;
else
       {
       System.out.println(""+counter);
       myMethod(--counter);
       return;
       }
}
\end{verbatim}
\subsection{Data Structures}
\paragraph{}
The data structures provided by the Java utility package are very powerful and perform a wide range of functions. These data structures consist of the following interface and classes:

\begin{itemize}
\item \textbf{Enumeration:} The Enumeration interface isn't itself a data structure, but it is very important within the context of other data structures. The Enumeration interface defines a means to retrieve successive elements from a data structure.
\item \textbf{BitSet:} The BitSet class implements a group of bits or flags that can be set and cleared individually.
\item \textbf{Vector:} The Vector class is similar to a traditional Java array, except that it can grow as necessary to accommodate new elements.
\item \textbf{Stack:} The Stack class implements a last-in-first-out (LIFO) stack of elements.
\item \textbf{Dictionary:} The Dictionary class is an abstract class that defines a data structure for mapping keys to values.
\item \textbf{Hashtable:} The Hashtable class provides a means of organizing data based on some user-defined key structure.
\item \textbf{Properties:} Properties is a subclass of Hashtable. It is used to maintain lists of values in which the key is a String and the value is also a String.
\end{itemize}


\subsection{Exception Handling}
\paragraph{}
Blabla

%----------------------------------------------------------------------------------------
%	5. Android Environment
%----------------------------------------------------------------------------------------

\section{Android Environment}
\paragraph{}
Blabla

\subsection{Methods and data structure selection}
\paragraph{}
Blabla

\subsection{Analysis adaptation to Android Environment}
\paragraph{}
Blabla

\subsection{Android App Example}
\paragraph{}
Blabla

\subsection{Code}

\subsection{Description}

\subsection{CCFG}

\subsection{Tables}

%----------------------------------------------------------------------------------------
%	6. Conclusions
%----------------------------------------------------------------------------------------

\section{Conclusions}
\paragraph{}
Blabla

\subsection{Future developments}
\paragraph{}
Blabla

%----------------------------------------------------------------------------------------
%	NOTES AND BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

{\footnotesize \bibliographystyle{acm}
\bibliography{biblio}
}

\theendnotes

%----------------------------------------------------------------------------------------
%	END OF DOCUMENT
%----------------------------------------------------------------------------------------

\end{document}







