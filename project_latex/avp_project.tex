% TEMPLATE for Usenix papers, specifically to meet requirements of
%  USENIX '05
% originally a template for producing IEEE-format articles using LaTeX.
%   written by Matthew Ward, CS Department, Worcester Polytechnic Institute.
% adapted by David Beazley for his excellent SWIG paper in Proceedings,
%   Tcl 96
% turned into a smartass generic template by De Clarke, with thanks to
%   both the above pioneers
% use at your own risk.  Complaints to /dev/null.
% make it two column with no page numbering, default is 10 point

% Munged by Fred Douglis <douglis@research.att.com> 10/97 to separate
% the .sty file from the LaTeX source template, so that people can
% more easily include the .sty file into an existing document.  Also
% changed to more closely follow the style guidelines as represented
% by the Word sample file. 

% Note that since 2010, USENIX does not require endnotes. If you want
% foot of page notes, don't include the endnotes package in the 
% usepackage command, below.

%----------------------------------------------------------------------------------------
%	PACKAGES & CONFIG
%----------------------------------------------------------------------------------------

%\documentclass[paper=a4, fontsize=11pt]{article} % A4 paper and 11pt font size
\documentclass[letterpaper,twocolumn,10pt]{article}

\usepackage{usenix,epsfig,endnotes}
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{listings} % source code package
\usepackage{tikz} % graph package
\usepackage{supertabular} % table span multiple pages
\usetikzlibrary{shapes,arrows}

%\usepackage{sectsty} % Allows customizing section commands
%\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps
%\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\begin{document}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Analisys and Verification of Program Project 2014}

\author{
{\rm Gianluca Barbon}\\
gbarbon@dsi.unive.it
\and
{\rm Cristian De Zotti}\\
cdezotti@dsi.unive.it
\and
{\rm Marco Moscardo}\\
mmoscardo@dsi.unive.it
}
\date{July 1, 2014}
\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}


\subsection*{Abstract}
Your Abstract Text Goes Here.  Just a few facts.
Whet our appetites.


%----------------------------------------------------------------------------------------
%	1. Introduction
%----------------------------------------------------------------------------------------

\section{Introduction}
\paragraph{}
The aim of this analysis is to verify if the application variables contain confidential data, as a result of the use of certain methods that they have saved their results.  
In this paper we purpose an analysis to find all variables which are classified as potential exported variables using the notion of Class Control Flow Graph.
First of all we explain the idea of this analysis applying it to simplified object oriented programs and then using it to extended object oriented language which are the same of the language used by the Android platform.
Note: we use the abbreviation \lq\lq confidential methods \rq\rq for methods that generate data containing confidential information and \lq\lq confidential data \rq\rq to indicate the data generated by confidatial methods. We use the verb \lq\lq export \rq\rq to indicate all the possible ways to save/export confidential data.
Now the main question becomes: in an application that generates sensitive data, these data are exported?
\subsection{Data Definition}
\paragraph{}
Data can be classified in three different classes: \textit{personal, confidential or sensitive.} The main difference between these types of data is the kind of information which are related. 

\textbf{Personal data} is '\emph{data which relates to a living individual who can be identified from those data OR from those data and other information which is in the possession of or is likely to come into the possession of the data controller (e.g. University) and includes any expression of opinion about the individual}' - Data Protection Act (1998).

\textbf{Confidential data} is data that can be connected to the person providing them or that could lead to the identification of a person referred to, such as names, address, etc. This information, which are not in the public domain, are given in confidence, or with data agreed to be kept '\textit{confidential}' (namely secret) between two parties. 

\textbf{Sensitive data} is '\emph{data on a person's race, ethnic origin, political opinion, religious or similar beliefs, trade union membership, physical or mental health or condition, sexual life, commission or alleged commission of an offence, proceedings for an offence (alleged to have been) committed, disposal of such proceedings or the sentence of any court in such proceedings} - Data Protection Act (1998)

In this paper we are only focused on the confidential data that is the most exported data without authorization.

%----------------------------------------------------------------------------------------
%	2. Safeness Analysis Formal Definition
%----------------------------------------------------------------------------------------

\section{Safeness Analysis Formal Definition}
\paragraph{}
Our analysis will be based on the Data Flow analysis techniques, and will be named \emph{Safeness Analysis}. As said before, it will identify exported elements that contains confidential data. This analysis will determine exported and possibly confidential variables at the entry and exit point of each node. We will consider the collection of values composed of $\{x, x[y, z, \ldots], n\}$ where \emph{x} is the exported variable, [\emph{y,z,...}] is the chain of variables used in the definition of \emph{x} and \emph{n} is the involved node. Moreover, we will consider $\{x, y, n\}$ as the variable \emph{x} equal to \emph{y} in node \emph{n}. Please notice that this last statement has different meanings depending on the fact that the variable consist in an object or in a primitive element, but we will see this later in a more precise way.\\

Thus, variable \emph{x} and its chain are exported and potentially confidential if:
\begin{itemize}\itemsep2pt \parskip0pt \parsep0pt
\item a path \emph{p} from \emph{n} to \emph{m} exists
\item variable \emph{x} is exported and potentially\\ confidential in \emph{n}
\item variable \emph{x} is never re-defined in \emph{p}
\end{itemize}

We have to consider that our \emph{Safeness Analysis} is taking place in an Object Oriented environment. Anyway, we will deal later with complex concepts from O. O. programming, like interfaces and interfaces. On the other hand, we will first start from a simple pseudo-code version of an object oriented programming paradigm. That's to say, an o.o. programming language similar to Java that will use only classes, methods and creators, in order to ``make it simple''.

\subsection{Gen/Kill}
\paragraph{}
Let's consider operations that generate and kill information:
\begin{align*}
\begin{tabular}{  l l }
	$ gen_{SA}[\text{B}]= $ & $ \{ element\ is\ exported \} $\\ 
	& \\                  
	$  kill_{SA}[\text{B}]= $ & $ \{ element\ is\ not\ created\ by\ a\ $\\ 
	& $\ confidential\ method \} $ \\
\end{tabular}
\end{align*}

A more precise definition of \emph{gen} and \emph{kill} could be made considering also variable that are not exported directly, but are used in the definition of exported variable. But we decided to have simple \emph{gen} and \emph{kill} definition, and to improve it later for specific cases (please refer to section 2.3).\\
%We can expand \emph{gen} and \emph{kill} definition:\\
%\begin{align*}
%\begin{tabular}{  l l }
%	$ gen_{SA}[\text{B}]= $ & $ \{ var\ x\ is\ exported $\\ 
%	& OR \\
%	& $ var\ x\ is\ used\ by\ an\ exported\ variable\ y\ $\\ 
%	& $ ( so\ x\ is\ added\ in\ the\ chain\ of\ y ) \} $ \\
%	& \\                  
%	$  kill_{SA}[\text{B}]= $ & $ \{ var\ x\ is\ not\ created\ by\ a\ sensible\ method\ $\\
%    & OR \\ 
%    & $ chain\ of\ var\ x\ contains\ only\ variables\ $ \\
%    & $ that\ are\ not\ sensible\ \} $ \\
%\end{tabular}
%\end{align*}

\indent
In order to collect only variables that are exported, our analysis will start from the end of the program. Thus, it will be a \emph{Backward Analysis}. This behaviour is similar to the \emph{Live Variables Analysis}~\cite{Nielson:1999:PPA:555142} one. We can now specify the features of our analysis. 
\begin{description}
\item[\textbf{Analysis direction:}] backward
\item[\textbf{Confluence operator: }] union\\ $ \text{out}[B]\ =\ \cup\ \text{in}[S],\ over\ the\ successor\ S\ of\ B\  $
\item[\textbf{Initialization: }] empty set, \quad $ \emptyset $
\end{description}

It is now possible to define the equations of the analysis.
\subsection{Safeness Analysis equations}
\begin{gather*}
SA_\textrm{$exit$}(p)\ =\ 
\begin{cases}
\emptyset\qquad if\ p\ is\ a\ final\ point\ \\ \\
\cup\ \lbrace SA_\textrm{$entry$}(q)\ |\ q\ follows\ p\ in\ the\ CFG \rbrace 
\end{cases} \\ \\
SA_\textrm{$entry$}(p)\ =\ \text{gen}_\textrm{SA}(p)\ \cup\ (SA_\textrm{$exit$}(p)\ \textbackslash\ \text{kill}_\textrm{SA}(p)\ )
\end{gather*}

At the end of the analysis we will have two possible states:
\begin{itemize}
\item no more variables collected in our tables
\item some variables are still present in our tables
\end{itemize}
The first state means that the examined program is \emph{SAFE}. Indeed, if no variables are present in our analysis memory, all the variables considered possibly unsafe have been removed because they are certified as non confidential data.\\
On the other side, the second state means that the program is \emph{UNSAFE}. This is due to the fact that some variables remains in our analysis memory, confirming that these variables contain confidential data. Thus, our analysis is also capable of locating unsafe variables.

\subsection{Difference between objects and primitive data types}
\paragraph{}
The definitions given so far are not sufficient to describe our analysis. Indeed \emph{gen} and \emph{kill} are more complicated. We have to deal with different problems related to the object oriented paradigm. First of all, we have to consider that also variables used in the definition of elements that will be exported may contain confidential data. So a complete analysis has to consider also these variables.
Second, it is important to divide variables into two subsets:
\begin{itemize}
\item primitive variables
\item objects
\end{itemize}
This necessary distinction comes from various assumptions. Firs of all, in an object oriented programming language objects are passed by reference, while primitive variables are passed by copy. In example, in Java a variable that uses a class as type does not actually contain an object of that class. Instead, it only stores the position of the object in the system memory ~\cite{Horstmann:2008:BJ:1796502}. So we present the different cases in a more precise way.

\noindent \paragraph{Primitive Variables}
\begin{description}

\item[\texttt{export(x)}] \hfill \\
Variable \emph{x} is exported with a method. In this case the \emph{gen} step will add the record $\{x, n\}$ in the table into the \emph{gen} column.

\item[\texttt{x = y}] \hfill \\
The variable is copied from another one, and we know that it will be exported (notice that, in order to make this \emph{gen} step sound, we also have to know that variable \emph{x} will not change its value in the path between the copy and the exportation points). In this case the \emph{gen} step will add the record $\{x, y, n\}$ in the table into the \emph{gen} column. A later \emph{kill} (going backward after this statement) of the copied variable \emph{y} will remove the information added with this \emph{gen} step, and also the information related to the exportation of the \emph{x} variable.

\item[\texttt{x = method(y)}] \hfill \\
The variable is used in the creation of another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, x[y], n\}$ in the table into the \emph{gen} column. If the primitive variables involved as parameter are more than one, we will have a record like this: $\{x, x[y,x,...], n\}$.  A later \emph{kill} of the referred variable \emph{y} will remove the information added with this \emph{gen} step, but will not delete the information related to the exportation of the first variable \emph{x}. This is because, even if \emph{y} variable is \emph{SAFE}, the method that generates the first one may make use of confidential information, like other methods or variables belonging to its class, and so we cannot trust variable \emph{x}. In order to check the safeness of variable \emph{x}, we must expand the \emph{CFG} of this method.

\item[\texttt{x = method()}] \hfill \\
The variable \emph{x} is generated. If, by expanding and inspecting the \emph{CFG} of this method, we find out (or we already know) that it's \emph{not confidential}, we can perform a \emph{kill} step. Otherwise, no steps are performed.

\end{description}

\noindent \paragraph{Objects}
\begin{description}
\item[\texttt{x.export()}] \hfill \\
Object \emph{x} is exported with a method. In this case the \emph{gen} step will add the record $\{x, n\}$ in the table into the \emph{gen} column.

\item[\texttt{CClass x = y}] \hfill \\
The object is referred from another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, y, n\}$ in the table into the \emph{gen} column. A later \emph{kill} of the referred object (\emph{y}) will remove the information added with this \emph{gen} step, and also the information related to the exportation of the first object (\emph{x}).

\item[\texttt{CClass x = new CClass(y)}] \hfill \\
The object is used in the creation of another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, x[y], n\}$ in the table into the \emph{gen} column. A later \emph{kill} of the referred object \emph{y} will remove the information added with this \emph{gen} step, but will not delete the information related to the exportation of the first object (\emph{x}). This is because, even if \emph{y} object is \emph{SAFE}, the creator of the first one may make use of confidential information, and so we cannot trust the \emph{x} object. In order to check the safeness of the \emph{x} object, we must expand the \emph{CFG} of its constructor.

\item[\texttt{CClass x = new CClass()}] \hfill \\
The object \emph{x} is created. We cannot make any \emph{kill} step, because we don't know if the constructor of this object is \emph{SAFE}. As said for the previous case, we must expand and inspect its \emph{CFG}.
\end{description}

As we have just seen, primitive variables and objects have different behaviour in the \emph{gen} and \emph{kill} steps. Anyway, the syntax used in the tables of the analysis is quite similar.

\subsection{CCFG: Class Control Flow Graph~\cite{CCFG}}
\paragraph{}
For the construction of our Control Flow Graph, we must use a different technique in object-oriented language with respect to an imperative language. This is due to the fact that in the object-oriented language is the ability to use multiple classes within the same application, and then with our graph must be able to represent the application in its entirety, including the relationship between the various classes given by method calls.\\
Has been developed an algorithm that allows the construction of CCFG of application, considering also the relationships between the various classes. The algorithm consists of four steps:
\begin{itemize}
\item The first step is to create the CFG of the class in question. 
\item In the second step, however, for each method inside the class, the class of the method is added to ours, and we are replacing the node that contains the method invocation, with the corresponding CFG. This operation continues until they were covered all the methods contained within the application, including those present in the interior of the classes that are added in the course of work.  
\item In the third stepo is made ​​the update of the various edges of CCFG so that they are connected in an appropriate manner on all sides.
\item In the fourth step, the final, once finished all the above steps, it returns the CCFG application.
\end{itemize}

\subsubsection{CCFG Constructor Algorithm}
\lstset{basicstyle=\small\ttfamily, tabsize=2}
\begin{lstlisting}
algorithm: ConstructorCCFG(C):G
input: C a class
output: G a CCFG of C

begin ConstructCCFG
	
	/* Step1: Construct the class call 
	graph for the class C*/ 
	 G = Construct the CFG of C
	  
	/* Step2: Replace each call graph node 
	with the corresponding CFG */
	 foreach method M in C do
	  Add M class to C	  
	  Replace M node in G with CFG of M class

	/* Step3: Connect every individual 
	CFG */
	 Update edges appropriately 

	/* Step4: Return the completed 
	CCFG of G */
	 return G

end ConstructCCFG
\end{lstlisting}

\subsection{Safeness Analysis Algorithm}
\paragraph{}
The following shows the algorithm used to make the safeness analisys, which was derived from the equations introduced in Section 2.2:\\

\texttt{for each n \\
    in[n]:={ }; out[n]:={ } \\
repeat \\
    for each n \\
    in’[n]:=in[n]; out’[n]:=out[n] \\
        in[n] := use[n]}$\cup$\texttt{(out[n]-def[n])\\
        out[n]:=}
        
        



%----------------------------------------------------------------------------------------
%	3. Examples
%----------------------------------------------------------------------------------------

\section{Examples}
\paragraph{}
We now apply our analysis to some examples written with the proposed simple version of an object oriented programming language.

\subsection{Example 1}
\paragraph{}
In this example we will see a very simple application that uses two class.
\subsubsection{Code}

\begin{verbatim}
. class MClass{
.
1     void main (String[] args) {	    
2         Text t	 = new Text("Hello!");
3         exportMethod(t);
.     }
.
4     void exportMethod(Text t) {        
5         ...
.         //this method exports confidential values
.     }
. }
\end{verbatim}

\noindent We now have to consider Text class:
\begin{verbatim}
. class Text {
1     string s;
.	
2     Text(string b) { 	//constructor
3         string c	 = confidentialMethod();
4         this.s = b;
5         this.s = this.s + c;
.     }
.	
6     string confidentialMethod(){ 
.         //method with confidential values
7         string confidentialVariable;		
8         return confidentialVariable;
.     }
. }
\end{verbatim}

%\subsection{Dumb example}
%{\tt \small
%\begin{verbatim}
%...
%Text t	= new Text(confidentialText);
%...
%\end{verbatim}
%}
%But we also need to consider Text class: \\
%
%\begin{verbatim}
%class Text {
%    string s;	//class variable
%	
%    Text(string b) { 	//constructor
%        this.s = b;
%    }
%}
%\end{verbatim}
%
%In this example it is easy to see that the object t contains confidential datas.\\

\subsubsection{Description}
\paragraph{}
By only looking at \emph{MClass} object \emph{t} seems to be not confidential. Anyway, we must investigate also \emph{Text} class, because the constructor may contains methods that create confidential data in the new object. In order to do this, we can expand the CCFG of the \emph{text} constructor. In this way, we will see that the constructor makes use of \emph{ConfidentialMethod}, a method that generates confidential data. So, the object \emph{t} will be considered \emph{UNSAFE} and consequently also the application will be believed as \emph{UNSAFE}.

\subsubsection{CCFG}

% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define block styles
\tikzstyle{decision} = [diamond, draw, text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, align=left]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse, node distance=3cm,minimum height=2em]
\tikzstyle{back}=[draw, thick, rectangle, minimum height = 3em, minimum width = 3em]
\tikzstyle{every node}=[font=\footnotesize]
\scalebox{0.85}{
\begin{tikzpicture}[node distance = 2cm, auto][every node/.style={inner sep=0,outer sep=0}]
    % Place nodes
    \node [block] (MC1) {void main (String[] args) \{ \\    Text t = new Text("Hello!");\\     exportMethod(t);\\ \} };
    \node [block, below of=MC1] (MC2){void exportMethod(Text t) \{ \\ ... \\ \} };
    \node [block, right of=MC2, node distance=5cm] (T1) {Text(string b) \{\\ string c = confidentialMethod(); \\ this.s = b; \\ this.s = this.s + c; \\ \} };
    \node [block, below of=T1] (T2) {string confidentialMethod()\{ \\ string confidentialVariable; \\ return confidentialVariable;\\ \} };
    
    % Draw edges
    \path [line] (MC1) -- (MC2);
    \path [line] (T1) -- (T2);
    
    %class labels
    \path (MC2.south)+(-0.4,-0.4) node (MClass) {MClass Class};
    \path (T2.south)+(-0.4,-0.4) node (Text) {Text Class};

    %background shapes 
    \begin{pgfonlayer}{background}
        %MClass class
        \path (MC1.west |- MC1.north)+(-0.2,0.2) node (a) {};
        \path (MC2.south -| MC1.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
        %Text class                
        \path (T1.west |- T1.north)+(-0.2,0.2) node (a) {};
        \path (T2.south -| T1.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
    \end{pgfonlayer}   
    
    %curved arrows
    \begin{scope}[looseness=1.6]
        \path [draw, ->] (MC1) edge[out=0,in=90,->]  node [right] {} (T1);
        \path [draw, ->] (T1) edge[out=180,in=0,->]  node [right] {} (MC1);
        %\path [draw, ->] (T2) edge[out=270,in=0,->]  node [right] {} (T1);
        %\path [draw, ->] (MC1) edge[out=270,in=180,->]  node [right] {} (MC1);
    \end{scope} 
    
\end{tikzpicture}
}

\subsubsection{Tables}

\begin{supertabular}{|l|*{3}{c|}}
  \hline
  n & classname & gen & kill  \\
  \hline 
  3 & MClass & \{t,,3, MClass\} & \\ 
  2 & MClass & - & - \\
  5 & Text & \{t,t[c],5, Text\} & \\
  4 & Text & \{t,t[c,b],4, Text\} & \\
  3 & Text & - & - \\
  8 & Text &  & \\
  7 & Text &  & \\
  6 & Text &  & \\
  3 & Text &  & \\
  2 & Text &  & \\
  2 & MClass &  & \{b,2,MClass\}\\
  1 & MClass &  & \\
  \hline
\end{supertabular}


\begin{supertabular}{|l|*{3}{c|}}
  \hline
  n & classname & entry & exit  \\
  \hline 
  3 & MClass & \{t\} &  \\ 
  2 & MClass & - & -\\
  5 & Text & \{t, c\} & \{t\} \\
  4 & Text & \{t, c, b\} & \{t, c\} \\
  3 & Text & - & - \\
  8 & Text & \{t, c, b\} & \{t, c, b\}    \\
  7 & Text & \{t, c, b\} & \{t, c, b\}    \\
  6 & Text & \{t, c, b\} & \{t, c, b\}    \\
  3 & Text & \{t, c, b\} & \{t, c, b\}    \\
  2 & Text & \{t, c, b\} & \{t, c, b\}    \\
  2 & MClass & \{t, c\} & \{t, c, b\}    \\
  1 & MClass & \{t, c\} & \{t, c\}    \\
  \hline
\end{supertabular}


\subsection{Example 2}

\subsubsection{Code}
{\tt \small
\begin{verbatim}
1    CustomClass x = new CustomClass();
2    CustomClass y = x;
3    y.export();
\end{verbatim}
}

\subsubsection{Description}
\paragraph{}
Partiamo dalla fine. Gen sull'ultima istruzione ci genera y. Sulla penultima dobbiamo killare y? No. Facciamo gen di x sulla catena di y. Infatti, anche se non viene generato da un metodo sensibile, non sappiamo ancora se x sia sensibile o meno. Nel caso lo fosse, considereremmo anche y sensibile. Quindi per il momento non abbiamo kill. Continuando a risalire nel codice, troviamo il punto dove viene definita la variabile x. Si tratta di un metodo sensibile, quindi non facciamo kill. Inoltre, ora sappiamo che anche y \`e sensibile. Questo esempio risulta quindi UNSAFE.\\

Consideriamo il caso in cui x è sicuramente non sensibile. In questo caso abbiamo un comportamento simile al precedente, ma la situazione cambia nel momento in cui scopriamo che x non proviene da una funzione sensibile. A questo punto, verranno killate sia x che y. Alla fine avremo l'insieme vuoto, ci\`o significa che quest'esempio \`e SAFE.\\

The last example has been created following the first example of section 2 of this document. We first notice that we can have various possibilities when creating a new object:\\

\begin{itemize}
  \item constructor doesn't make use of confidential data
  \item constructor USES confidential data
  \item parameters used in the constructor invocation contain confidential data
  \item \ldots
\end{itemize}

If we apply backward analysis to this example, we will have the following steps:

\begin{enumerate}
\item gen step for object y (with export method)
\item x is added to the chain of y
\item the kill step of x and y depends on the results of the analysis of the constructor method and of the CustomClass class (notice that variables declared in the class may be obtained as results of confidential methods)
\end{enumerate}

Furthermore, it's important to remark that a class may declare confidential variables, anyway if we don't have methods that export these variables, the object is SAFE. More precisely, objects may contain methods that exports confidential data, but if these methods are not used in the analysed application, these objects can be considered SAFE. \\

\subsubsection{CCFG}
% Define block styles
\tikzstyle{decision} = [diamond, draw, 
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, 
    text width=15em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
    minimum height=2em]
\begin{center}
\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [block] (init) {CustomClass x = new CustomClass;};
    %\node [cloud, left of=init] (expert) {expert};
    %\node [cloud, right of=init] (system) {system};
    \node [block, below of=init] (2){CustomClass y = x;};
    \node [block, below of=2] (3) {y.export;};
    %\node [block, left of=evaluate, node distance=3cm] (update) {update model};
    %\node [decision, below of=evaluate] (decide) {is best candidate better?};
    %\node [block, below of=decide, node distance=3cm] (stop) {stop};
    % Draw edges
    \path [line] (init) -- (2);
    \path [line] (2) -- (3);
    %\path [line] (evaluate) -- (decide);
    %\path [line] (decide) -| node [near start] {yes} (update);
    %\path [line] (update) |- (identify);
    %\path [line] (decide) -- node {no}(stop);
    %\path [line,dashed] (expert) -- (init);
    %\path [line,dashed] (system) -- (init);
    %\path [line,dashed] (system) |- (evaluate);
\end{tikzpicture}
\end{center}

\subsubsection{Tables}
\begin{align*}
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & gen & kill  \\
  \hline 
  3 & $\{y \}$ & \\ 
  2 & $\{y, x\}$ & \\
  1 &  & $\{x\}$ \\
  \hline
\end{tabular}
\qquad
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & exit & entry  \\
  \hline 
  3 &  & \\ 
  2 &  &\\
  1 &  & \\
  \hline
\end{tabular}
\end{align*}

%----------------------------------------------------------------------------------------
%	4. Issues with a real Object Oriented Language
%----------------------------------------------------------------------------------------

\section{Issues with a real Object Oriented Language}
\paragraph{}
Blabla

\subsection{Inheritance}
\paragraph{}
Inheritance Blabla

\subsection{Extension}
\paragraph{}
Extension Blabla

\subsection{Interfaces}
\paragraph{}
Interfaces Blabla

\subsection{Overloading}
\paragraph{}
Overloading Blabla

\subsection{Overriding}
\paragraph{}
Overriding Blabla

\subsection{Recursion}
\paragraph{}
Recursion Blabla

\subsection{\ldots}
\paragraph{}
Blabla


%----------------------------------------------------------------------------------------
%	5. Android Environment
%----------------------------------------------------------------------------------------

\section{Android Environment}
\paragraph{}
Blabla

\subsection{Methods and data structure selection}
\paragraph{}
Blabla

\subsection{Analysis adaptation to Android Environment}
\paragraph{}
Blabla

\subsection{Android App Example}
\paragraph{}
Blabla

%----------------------------------------------------------------------------------------
%	6. Conclusions
%----------------------------------------------------------------------------------------

\section{Conclusions}
\paragraph{}
Blabla

\subsection{Future developments}
\paragraph{}
Blabla

%----------------------------------------------------------------------------------------
%	NOTES AND BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

{\footnotesize \bibliographystyle{acm}
\bibliography{biblio}
}

\theendnotes

%----------------------------------------------------------------------------------------
%	END OF DOCUMENT
%----------------------------------------------------------------------------------------

\end{document}







