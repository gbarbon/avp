% TEMPLATE for Usenix papers, specifically to meet requirements of
%  USENIX '05
% originally a template for producing IEEE-format articles using LaTeX.
%   written by Matthew Ward, CS Department, Worcester Polytechnic Institute.
% adapted by David Beazley for his excellent SWIG paper in Proceedings,
%   Tcl 96
% turned into a smartass generic template by De Clarke, with thanks to
%   both the above pioneers
% use at your own risk.  Complaints to /dev/null.
% make it two column with no page numbering, default is 10 point

% Munged by Fred Douglis <douglis@research.att.com> 10/97 to separate
% the .sty file from the LaTeX source template, so that people can
% more easily include the .sty file into an existing document.  Also
% changed to more closely follow the style guidelines as represented
% by the Word sample file. 

% Note that since 2010, USENIX does not require endnotes. If you want
% foot of page notes, don't include the endnotes package in the 
% usepackage command, below.

%----------------------------------------------------------------------------------------
%	PACKAGES & CONFIG
%----------------------------------------------------------------------------------------

%\documentclass[paper=a4, fontsize=11pt]{article} % A4 paper and 11pt font size
\documentclass[letterpaper,twocolumn,10pt]{article}

\usepackage{usenix,epsfig,endnotes}
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{listings} % source code package
\usepackage{tikz} % graph package
\usepackage{supertabular} % table span multiple pages
\usetikzlibrary{shapes,arrows}
\usepackage{courier}
\usepackage[hyphens]{url} %for showing urls in bibliography
%\usepackage{hyperref} %for breaking urls in bib
%\hypersetup{colorlinks=true,breaklinks=true} %for showing urls

%\usepackage{sectsty} % Allows customizing section commands
%\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps
%\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\begin{document}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Analisys and Verification of Program Project 2014}

\author{
{\rm Gianluca Barbon}\\
gbarbon@dsi.unive.it
\and
{\rm Cristian De Zotti}\\
cdezotti@dsi.unive.it
\and
{\rm Marco Moscardo}\\
mmoscardo@dsi.unive.it
}
\date{July 1, 2014}
\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}


\subsection*{Abstract}
Your Abstract Text Goes Here.  Just a few facts.
Whet our appetites.


%----------------------------------------------------------------------------------------
%	1. Introduction
%----------------------------------------------------------------------------------------

\section{Introduction}
\paragraph{}
The aim of this analysis is to verify if the application variables contain confidential data, as a result of the use of certain methods that they have saved their results.  
In this paper we purpose an analysis to find all variables which are classified as potential exported variables using the notion of Class Control Flow Graph.
First of all we explain the idea of this analysis applying it to simplified object oriented programs and then using it to extended object oriented language which are the same of the language used by the Android platform.
Note: we use the abbreviation \lq\lq confidential methods\rq\rq\ for methods that generate data containing confidential information and \lq\lq confidential data\rq\rq\ to indicate the data generated by confidatial methods. We use the verb \lq\lq export \rq\rq to indicate all the possible ways to save/export confidential data.
Now the main question becomes: in an application that generates sensitive data, are these data exported?
\subsection{Data Definition}
\paragraph{}
Data can be classified in three different classes: \textit{personal, confidential or sensitive.} The main difference between these types of data is the kind of information which are related. 

\textbf{Personal data} is '\emph{data which relates to a living individual who can be identified from those data OR from those data and other information which is in the possession of or is likely to come into the possession of the data controller (e.g. University) and includes any expression of opinion about the individual}' - Data Protection Act (1998).

\textbf{Confidential data} is data that can be connected to the person providing them or that could lead to the identification of a person referred to, such as names, address, etc. This information, which are not in the public domain, are given in confidence, or with data agreed to be kept '\textit{confidential}' (namely secret) between two parties. 

\textbf{Sensitive data} is '\emph{data on a person's race, ethnic origin, political opinion, religious or similar beliefs, trade union membership, physical or mental health or condition, sexual life, commission or alleged commission of an offence, proceedings for an offence (alleged to have been) committed, disposal of such proceedings or the sentence of any court in such proceedings} - Data Protection Act (1998)

In this paper we are only focused on the confidential data that is the most exported data without authorization.

%----------------------------------------------------------------------------------------
%	2. Safeness Analysis Formal Definition
%----------------------------------------------------------------------------------------

\section{Safeness Analysis Formal Definition}
\paragraph{}
Our analysis will be based on the Data Flow analysis techniques, and will be named \emph{Safeness Analysis}. As said before, it will identify exported elements that contains confidential data. This analysis will determine exported and possibly confidential variables at the entry and exit point of each node. We will consider the collection of values composed of $\{x, x[y, z, \ldots], n\}$ where \emph{x} is the exported variable, [\emph{y,z,...}] is the chain of variables used in the definition of \emph{x} and \emph{n} is the involved node. Moreover, we will consider $\{x, y, n\}$ as the variable \emph{x} equal to \emph{y} in node \emph{n} (possibly, we can use node number \emph{n} in association with the name of class, separated by a comma, in case the program has more than one class). Please notice that this last statement has different meanings depending on the fact that the variable consist in an object or in a primitive element, but we will see this later in a more precise way.\\

Thus, variable \emph{x} and its chain are exported and potentially confidential if:
\begin{itemize}\itemsep2pt \parskip0pt \parsep0pt
\item a path \emph{p} from \emph{n} to \emph{m} exists
\item variable \emph{x} is exported and potentially\\ confidential in \emph{n}
\item variable \emph{x} is never re-defined in \emph{p}
\end{itemize}

We have to consider that our \emph{Safeness Analysis} is taking place in an Object Oriented environment. Anyway, we will deal later with complex concepts from O. O. programming, like inheritance and interfaces. On the other hand, we will first start from a simple pseudo-code version of an object oriented programming paradigm. That's to say, an o.o. programming language similar to Java that will use only classes, methods and creators, in order to ``make it simple''.

\subsection{Gen/Kill}
\paragraph{}
Let's consider operations that generate and kill information:
\begin{align*}
\begin{tabular}{  l l }
	$ gen_{SA}[\text{B}]= $ & $ \{ element\ is\ exported \} $\\ 
	& \\                  
	$  kill_{SA}[\text{B}]= $ & $ \{ element\ is\ not\ created\ by\ a\ $\\ 
	& $\ confidential\ method \} $ \\
\end{tabular}
\end{align*}

A more precise definition of \emph{gen} and \emph{kill} could be made considering also variable that are not exported directly, but are used in the definition of exported variable. But we decided to have simple \emph{gen} and \emph{kill} definition, and to improve it later for specific cases (please refer to section 2.3).\\
%We can expand \emph{gen} and \emph{kill} definition:\\
%\begin{align*}
%\begin{tabular}{  l l }
%	$ gen_{SA}[\text{B}]= $ & $ \{ var\ x\ is\ exported $\\ 
%	& OR \\
%	& $ var\ x\ is\ used\ by\ an\ exported\ variable\ y\ $\\ 
%	& $ ( so\ x\ is\ added\ in\ the\ chain\ of\ y ) \} $ \\
%	& \\                  
%	$  kill_{SA}[\text{B}]= $ & $ \{ var\ x\ is\ not\ created\ by\ a\ sensible\ method\ $\\
%    & OR \\ 
%    & $ chain\ of\ var\ x\ contains\ only\ variables\ $ \\
%    & $ that\ are\ not\ sensible\ \} $ \\
%\end{tabular}
%\end{align*}

\indent
In order to collect only variables that are exported, our analysis will start from the end of the program. Thus, it will be a \emph{Backward Analysis}. This behaviour is similar to the \emph{Live Variables Analysis}~\cite{Nielson:1999:PPA:555142} one. We can now specify the features of our analysis. 
\begin{description}
\item[\textbf{Analysis direction:}] backward
\item[\textbf{Confluence operator: }] union\\ $ \text{out}[B]\ =\ \cup\ \text{in}[S],\ over\ the\ successor\ S\ of\ B\  $
\item[\textbf{Initialization: }] empty set, \quad $ \emptyset $
\end{description}

It is now possible to define the equations of the analysis.
\subsection{Safeness Analysis equations}
\begin{gather*}
SA_\textrm{$exit$}(p)\ =\ 
\begin{cases}
\emptyset\qquad if\ p\ is\ a\ final\ point\ \\ \\
\cup\ \lbrace SA_\textrm{$entry$}(q)\ |\ q\ follows\ p\ in\ the\ CFG \rbrace 
\end{cases} \\ \\
SA_\textrm{$entry$}(p)\ =\ \text{gen}_\textrm{SA}(p)\ \cup\ (SA_\textrm{$exit$}(p)\ \textbackslash\ \text{kill}_\textrm{SA}(p)\ )
\end{gather*}

At the end of the analysis we will have two possible states:
\begin{itemize}
\item no more variables collected in our tables
\item some variables are still present in our tables
\end{itemize}
The first state means that the examined program is \emph{SAFE}. Indeed, if no variables are present in our analysis memory, all the variables considered possibly unsafe have been removed because they are certified as non confidential data.\\
On the other side, the second state means that the program is \emph{UNSAFE}. This is due to the fact that some variables remains in our analysis memory, confirming that these variables contain confidential data. Thus, our analysis is also capable of locating unsafe variables.

\subsection{Difference between objects and primitive data types}
\paragraph{}
The definitions given so far are not sufficient to describe our analysis. Indeed \emph{gen} and \emph{kill} are more complicated. We have to deal with different problems related to the object oriented paradigm. First of all, we have to consider that also variables used in the definition of elements that will be exported may contain confidential data. So a complete analysis has to consider also these variables.
Second, it is important to divide variables into two subsets:
\begin{itemize}
\item primitive variables
\item objects
\end{itemize}
This necessary distinction comes from various assumptions. Firs of all, in an object oriented programming language objects are passed by reference, while primitive variables are passed by copy. In example, in Java a variable that uses a class as type does not actually contain an object of that class. Instead, it only stores the position of the object in the system memory ~\cite{Horstmann:2008:BJ:1796502}. So we present the different cases in a more precise way.

\noindent \paragraph{Primitive Variables}
\begin{description}

\item[\texttt{export(x)}] \hfill \\
Variable \emph{x} is exported with a method. In this case the \emph{gen} step will add the record $\{x, n\}$ in the table into the \emph{gen} column.

\item[\texttt{x = y}] \hfill \\
The variable is copied from another one, and we know that it will be exported (notice that, in order to make this \emph{gen} step sound, we also have to know that variable \emph{x} will not change its value in the path between the copy and the exportation points). In this case the \emph{gen} step will add the record $\{x, y, n\}$ in the table into the \emph{gen} column. A later \emph{kill} (going backward after this statement) of the copied variable \emph{y} will remove the information added with this \emph{gen} step, and also the information related to the exportation of the \emph{x} variable.

\item[\texttt{x = method(y)}] \hfill \\
The variable is used in the creation of another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, x[y], n\}$ in the table into the \emph{gen} column. If the primitive variables involved as parameter are more than one, we will have a record like this: $\{x, x[y,x,...], n\}$.  A later \emph{kill} of the referred variable \emph{y} will remove the information added with this \emph{gen} step, but will not delete the information related to the exportation of the first variable \emph{x}. This is because, even if \emph{y} variable is \emph{SAFE}, the method that generates the first one may make use of confidential information, like other methods or variables belonging to its class, and so we cannot trust variable \emph{x}. In order to check the safeness of variable \emph{x}, we must expand the \emph{CFG} of this method.

\item[\texttt{x = method()}] \hfill \\
The variable \emph{x} is generated. If, by expanding and inspecting the \emph{CFG} of this method, we find out (or we already know) that it's \emph{not confidential}, we can perform a \emph{kill} step. Otherwise, no steps are performed.

\end{description}

\noindent \paragraph{Objects}
\begin{description}
\item[\texttt{x.export()}] \hfill \\
Object \emph{x} is exported with a method. In this case the \emph{gen} step will add the record $\{x, n\}$ in the table into the \emph{gen} column.

\item[\texttt{CClass x = y}] \hfill \\
The object is referred from another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, y, n\}$ in the table into the \emph{gen} column. A later \emph{kill} of the referred object (\emph{y}) will remove the information added with this \emph{gen} step, and also the information related to the exportation of the first object (\emph{x}).

\item[\texttt{CClass x = new CClass(y)}] \hfill \\
The object is used in the creation of another one, and the last one is exported. In this case the \emph{gen} step will add the record $\{x, x[y], n\}$ in the table into the \emph{gen} column. A later \emph{kill} of the referred object \emph{y} will remove the information added with this \emph{gen} step, but will not delete the information related to the exportation of the first object (\emph{x}). This is because, even if \emph{y} object is \emph{SAFE}, the creator of the first one may make use of confidential information, and so we cannot trust the \emph{x} object. In order to check the safeness of the \emph{x} object, we must expand the \emph{CFG} of its constructor.

\item[\texttt{CClass x = new CClass()}] \hfill \\
The object \emph{x} is created. We cannot make any \emph{kill} step, because we don't know if the constructor of this object is \emph{SAFE}. As said for the previous case, we must expand and inspect its \emph{CFG}.
\end{description}

As we have just seen, primitive variables and objects have different behaviour in the \emph{gen} and \emph{kill} steps. Anyway, the syntax used in the tables of the analysis is quite similar. Furthermore, it's important to remark that a class may declare confidential variables, anyway if we don't have methods that export these variables, the object is \emph{SAFE}. More precisely, objects may contain methods that exports confidential data, but if these methods are not used in the analysed application, these objects can be considered \emph{SAFE}. 

\subsection{CCFG: Class Control Flow Graph~\cite{CCFG}}
\paragraph{}
For the construction of our Control Flow Graph, we must use a different technique in object-oriented language with respect to an imperative language. This is due to the fact that in the object-oriented language  multiple classes exist within the same application, and thus our graph must be able to represent the application in its entirety, including the relationship between the various classes given by method calls.\\
It has been developed an algorithm that allows the construction of CCFG of the application, considering also the relationships between the various classes. The algorithm consists of four steps:
\begin{itemize}
\item The first step is to create the CFG of the class in question. 
\item In the second step, however, for each method inside the class, the class of the method is added to ours, and we are replacing the node that contains the method invocation, with the corresponding CFG. This operation continues until all the methods contained within the application are covered, including those present in the interior of the classes that are added in the course of work.  
\item In the third step the update of the various edges of CCFG is made, so that they are connected in an appropriate manner on all sides.
\item In the fourth step, the final one, once finished all the above steps, the algorithms returns the CCFG application.
\end{itemize}

\subsubsection{CCFG Constructor Algorithm}
\lstset{basicstyle=\small\ttfamily, tabsize=2}
\begin{lstlisting}
algorithm: ConstructorCCFG(C):G
input: C a class
output: G a CCFG of C

begin ConstructCCFG
	
	/* Step1: Construct the class call 
	graph for the class C*/ 
	 G = Construct the CFG of C
	  
	/* Step2: Replace each call graph node 
	with the corresponding CFG */
	 foreach method M in C do
	  Add M class to C	  
	  Replace M node in G with CFG of M class

	/* Step3: Connect every individual 
	CFG */
	 Update edges appropriately 

	/* Step4: Return the completed 
	CCFG of G */
	 return G

end ConstructCCFG
\end{lstlisting}

\subsection{Safeness Analysis Algorithm}
\paragraph{}
The following section shows the algorithm used to perform the safeness analysis, which was derived from the equations introduced in Section 2.2, applied to the CCFG of the application:
\begin{tabbing}
% fissiamo le posizioni dei tab
~ \hspace{0.2cm} \= ~ \hspace{0.4cm} \= ~ \hspace{0.6cm} \= \\
\textbf{for each} node n in CCFG\\
\> in[n]:= $\emptyset$; out[n]:= $\emptyset$;\\
\textbf{repeat}\\
\> \textbf{for each} node n in CCFG \textbf{in reverse topsort order}\\
\>\> in'[n]:= in[n]; \\
\>\> out'[n]:= out[n]; \\
\>\> out[n]:= $\cup$\{in[m] | m $\in$ succ[n]\};\\
\>\> in[n]:= gen[n] $\cup$ (out[n]-kill[n]);\\
\textbf{until} (in'[n]= in[n] \&\& out'[n]= out[n] for all n)
\end{tabbing}    
        



%----------------------------------------------------------------------------------------
%	3. Examples
%----------------------------------------------------------------------------------------

%column break
\vfill
\break

\section{Examples}
\paragraph{}
We now apply our analysis to some examples written with the proposed simple version of an object oriented programming language.

\subsection{Example 1}

\subsubsection{Code}
\begin{verbatim}
1    CustomClass x = new CustomClass();
2    CustomClass y = x;
3    y.export();
\end{verbatim}

\subsubsection{Description}
\paragraph{}
This example has been created in order to show how important can be a Class Constructor in considering a variable confidential or not. We first notice that we can have various possibilities when creating a new object:
\begin{itemize}
  \item constructor doesn't make use of confidential data
  \item constructor USES confidential data
  \item parameters used in the constructor invocation contain confidential data
\end{itemize}

If we apply our analysis to this example, we will have the following steps:

\begin{enumerate}
\item gen step for object y (with export method)
\item object y results as a reference to x, so also x is added in the table
\item the kill step of x and y depends on the results of the analysis of the constructor method and of the CustomClass class (notice that variables declared in the class may be obtained as results of confidential methods)
\end{enumerate}

We can see that it is important to expand completely a CCFG in order to discover all the interesting path. So, by expanding the CCFG of \emph{CustomClass} we can have two cases:
\begin{itemize}
  \item constructor USES confidential data, so variables \emph{x} and \emph{y} cannot be killed, thus the application is \emph{UNSAFE}
  \item constructor doesn't make use of confidential data, so variables \emph{x} and \emph{y} are  both killed and the application is \emph{SAFE}
\end{itemize}

\subsubsection{CCFG}
%% Define block styles
%\tikzstyle{decision} = [diamond, draw, 
%    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
%\tikzstyle{block} = [rectangle, draw, 
%    text width=15em, text centered, rounded corners, minimum height=4em]
%\tikzstyle{line} = [draw, -latex']
%\tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
%    minimum height=2em]
%\begin{center}
%\begin{tikzpicture}[node distance = 2cm, auto]
%    % Place nodes
%    \node [block] (init) {CustomClass x = new CustomClass;};
%    \node [block, below of=init] (2){CustomClass y = x;};
%    \node [block, below of=2] (3) {y.export;};
%
%    % Draw edges
%    \path [line] (init) -- (2);
%    \path [line] (2) -- (3);
%\end{tikzpicture}
%\end{center}

% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define block styles
\tikzstyle{block} = [rectangle, draw, align=left]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{every node}=[font=\footnotesize]
\scalebox{0.85}{
\begin{tikzpicture}[node distance = 1cm, auto][every node/.style={inner sep=0,outer sep=0}]
    % Place nodes
    \node [block] (1) {CustomClass x = new CustomClass;};
    \node [block, below of=1] (2){CustomClass y = x;};
    \node [block, below of=2] (3) {y.export;};
    \node [below of=3, node distance = 2em] (dummy) {. . .};
    \node [below of=dummy, node distance = 2em] (method) {void export() \{...\}};
    \node [right of=2, node distance = 4cm] (CC) {CustomClass} edge[out=90,in=0,<-] (1.east); 
    \node [below of=CC, node distance = 2em] (dummy2) {. . .};
    
    % Draw edges
    \path [line] (1) -- (2);
    \path [line] (2) -- (3);
    
    %class labels
    \path (method.south)+(-0.8,-0.4) node (Class) {Main Class};
    %\path (dummy2.south)+(-0.4,-0.4) node (CClass) {CustomClass};

    %background shapes 
    \begin{pgfonlayer}{background}
        %Main Class
        \path (1.west |- 1.north)+(-0.2,0.2) node (a) {};
        \path (method.south -| 1.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
        %CustomClass
        \path (CC.west |- CC.north)+(-0.2,0.2) node (a) {};
        \path (dummy2.south -| CC.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
    \end{pgfonlayer}   
    
    %curved arrows
    \begin{scope}[looseness=1.6]
        \path [draw, ->] (3) edge[out=180,in=180,->]  node [right] {} (method);
    \end{scope} 
    
\end{tikzpicture}
}

\subsubsection{Tables}
We present here two possible version of tables. The first one show the case in which the constructor is \emph{UNSAFE}.
\begin{align*}
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & gen & kill  \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \\
  1 &  & \{x\} \\
  \hline
\end{tabular}
\qquad
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & entry & exit \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \{y \}\\
  1 & \{y, x\} & \{y, x\} \\
  \hline
\end{tabular}
\end{align*}

While the second one show the case in which the constructor is \emph{SAFE}. As we can see in the tables below, the variables under suspicion are killed and the application is considered \emph{SAFE}.
\begin{align*}
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & gen & kill  \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \\
  1 &  & \{x, y\} \\
  \hline
\end{tabular}
\qquad
\begin{tabular}{|l|*{2}{c|}}
  \hline
  n & entry & exit \\
  \hline 
  3 & \{y \} & \\ 
  2 & \{y, x\} & \{y \}\\
  1 &  & \{y, x\} \\
  \hline
\end{tabular}
\end{align*}

\subsection{Example 2}
\paragraph{}
In this example we will see a very simple application that uses two class.
\subsubsection{Code}

\begin{verbatim}
. class MClass{
.
1     void main (String[] args) {	    
2         Text t = new Text("Hello!");
3         exportMethod(t);
.     }
.
4     void exportMethod(Text t) {        
5         ...
.         //this method exports 
.         //confidential values
.     }
. }
\end{verbatim}

\noindent We now have to consider Text class:
\begin{verbatim}
. class Text {
1     string s;
.	
2     Text(string b) { 	//constructor
3         string c = confidentialMethod();
4         this.s = b;
5         this.s = this.s + c;
.     }
.	
6     string confidentialMethod(){ 
.         //creates confidential values
7         string confidentialVariable;		
8         return confidentialVariable;
.     }
. }
\end{verbatim}

%\subsection{Dumb example}
%{\tt \small
%\begin{verbatim}
%...
%Text t	= new Text(confidentialText);
%...
%\end{verbatim}
%}
%But we also need to consider Text class: \\
%
%\begin{verbatim}
%class Text {
%    string s;	//class variable
%	
%    Text(string b) { 	//constructor
%        this.s = b;
%    }
%}
%\end{verbatim}
%
%In this example it is easy to see that the object t contains confidential datas.\\

\subsubsection{Description}
\paragraph{}
By only looking at \emph{MClass} object \emph{t} seems to be not confidential. Anyway, we must investigate also \emph{Text} class, because the constructor may contains methods that create confidential data in the new object. In order to do this, we can expand the CCFG of the \emph{Text} constructor. In this way, we will see that the constructor makes use of \emph{ConfidentialMethod}, a method that generates confidential data. So, the object \emph{t} will be considered \emph{UNSAFE} and consequently also the application will be believed as \emph{UNSAFE}.

\subsubsection{CCFG}

% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define block styles
\tikzstyle{block} = [rectangle, draw, align=left]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{every node}=[font=\footnotesize]
%\scalebox{0.85}{
%\begin{tikzpicture}[node distance = 2cm, auto][every node/.style={inner sep=0,outer sep=0}]
%    % Place nodes
%    \node [block] (MC1) {void main (String[] args) \{ \\    Text t = new Text("Hello!");\\     exportMethod(t);\\ \} };
%    \node [block, below of=MC1] (MC2){void exportMethod(Text t) \{ \\ ... \\ \} };
%    \node [block, right of=MC2, node distance=5cm] (T1) {Text(string b) \{\\ string c = confidentialMethod(); \\ this.s = b; \\ this.s = this.s + c; \\ \} };
%    \node [block, below of=T1] (T2) {string confidentialMethod()\{ \\ string confidentialVariable; \\ return confidentialVariable;\\ \} };
%    
%    % Draw edges
%    \path [line] (MC1) -- (MC2);
%    \path [line] (T1) -- (T2);
%    
%    %class labels
%    \path (MC2.south)+(-0.4,-0.4) node (MClass) {MClass Class};
%    \path (T2.south)+(-0.4,-0.4) node (Text) {Text Class};
%
%    %background shapes 
%    \begin{pgfonlayer}{background}
%        %MClass class
%        \path (MC1.west |- MC1.north)+(-0.2,0.2) node (a) {};
%        \path (MC2.south -| MC1.east)+(0.2,-0.2) node (b) {};
%        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
%        %Text class                
%        \path (T1.west |- T1.north)+(-0.2,0.2) node (a) {};
%        \path (T2.south -| T1.east)+(0.2,-0.2) node (b) {};
%        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
%    \end{pgfonlayer}   
%    
%    %curved arrows
%    \begin{scope}[looseness=1.6]
%        \path [draw, ->] (MC1) edge[out=0,in=90,->]  node [right] {} (T1);
%        \path [draw, ->] (T1) edge[out=180,in=0,->]  node [right] {} (MC1);
%        %\path [draw, ->] (T2) edge[out=270,in=0,->]  node [right] {} (T1);
%        %\path [draw, ->] (MC1) edge[out=270,in=180,->]  node [right] {} (MC1);
%    \end{scope} 
%    
%\end{tikzpicture}
%}

\hspace*{-7mm}\scalebox{0.85}{
\begin{tikzpicture}[node distance = 1cm, auto][every node/.style={inner sep=0,outer sep=0}]

    % MClass nodes
    \node [block] (MC1) {void main (String[] args) \{ };
    \node [block, below of=MC1] (MC2) {Text t = new Text("Hello!");};
    \node [block, below of=MC2] (MC3) {exportMethod(t);\} };
    \node [block, below of=MC3, node distance=4em] (MC4) {void exportMethod(Text t) \{ };
    \node [block, below of=MC4] (MC5) {...(content of exportMethod)...\} };
    
    % Text class nodes
    \node [block, right of=MC2, node distance=5cm] (T1) {string s;};
    \node [block, below of=T1, node distance=4em] (T2) {Text(string b) \{ };
    \node [block, below of=T2] (T3) {string c = confidentialMethod();};
    \node [block, below of=T3] (T4) {this.s = b; };
    \node [block, below of=T4] (T5) {this.s = this.s + c; \} };
    \node [block, below of=T5, node distance=4em] (T6) {string confidentialMethod()\{ };
    \node [block, below of=T6] (T7) {string confidentialVariable; };
    \node [block, below of=T7] (T8) {return confidentialVariable;\} };
    
    % Draw arrows between blocks internal to classes
    \path [line] (MC1) -- (MC2);
    \path [line] (MC2) -- (MC3);
    \path [line] (MC4) -- (MC5);    
    \path [line] (T2) -- (T3);
    \path [line] (T3) -- (T4);
    \path [line] (T4) -- (T5);
    \path [line] (T6) -- (T7);
    \path [line] (T7) -- (T8);
    
    %class labels
    \path (MC5.south)+(-0.4,-0.4) node (MClass) {MClass Class};
    \path (T8.south)+(-0.4,-0.4) node (Text) {Text Class};

    %background shapes 
    \begin{pgfonlayer}{background}
        %MClass class
        \path (MC5.west |- MC1.north)+(-0.2,0.2) node (a) {};
        \path (MC5.south -| MC5.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
        %Text class                
        \path (T3.west |- T1.north)+(-0.2,0.2) node (a) {};
        \path (T8.south -| T3.east)+(0.2,-0.2) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
    \end{pgfonlayer}   
    
    %curved arrows
    \begin{scope}[looseness=1.8]
        \path [draw, ->] (MC3) edge[out=180,in=180,->]  node [left] {} (MC4);
        \path [draw, ->] (MC2) edge[out=0,in=180,->]  node [right] {} (T2);
        \path [draw, ->] (T3) edge[out=180,in=180,->, bend right=73]  node [left] {} (T6);
    \end{scope} 
    
\end{tikzpicture}
}

\subsubsection{Tables}
\begin{center}
%\begin{supertabular}{|l|*{3}{c|}}
\begin{tabular}{|l|*{3}{c|}}
  \hline
  n & classname & gen & kill  \\
  \hline 
  3 & MClass & \{t,,3, MClass\} & \\ 
  %2 & MClass & - & - \\
  5 & Text & \{t,t[c],5, Text\} & \\
  4 & Text & \{t,t[c,b],4, Text\} & \\
  %3 & Text & - & - \\
  8 & Text &  & \\
  7 & Text &  & \\
  6 & Text &  & \\
  3 & Text &  & \\
  2 & Text &  & \\
  2 & MClass &  & \{b,2,MClass\}\\
  1 & MClass &  & \\
  \hline
%\end{supertabular}
\end{tabular}
\end{center}
\begin{center}
\begin{supertabular}{|l|*{3}{c|}}
  \hline
  n & classname & entry & exit  \\
  \hline 
  3 & MClass & \{t\} &  \\ 
  %2 & MClass & - & -\\
  5 & Text & \{t, c\} & \{t\} \\
  4 & Text & \{t, c, b\} & \{t, c\} \\
  %3 & Text & - & - \\
  8 & Text & \{t, c, b\} & \{t, c, b\}    \\
  7 & Text & \{t, c, b\} & \{t, c, b\}    \\
  6 & Text & \{t, c, b\} & \{t, c, b\}    \\
  3 & Text & \{t, c, b\} & \{t, c, b\}    \\
  2 & Text & \{t, c, b\} & \{t, c, b\}    \\
  2 & MClass & \{t, c\} & \{t, c, b\}    \\
  1 & MClass & \{t, c\} & \{t, c\}    \\
  \hline
\end{supertabular}
\end{center}

%----------------------------------------------------------------------------------------
%	4. Issues with a real Object Oriented Language
%----------------------------------------------------------------------------------------

\section{Issues with a real Object Oriented Language}
\paragraph{}
This section will explore some specific features of the object oriented programming languages applied to our analysis, in order to see whether it works or it should be expanded. When necessary and possible, we propose a solution to extend the analysis to these feature. Descriptions may make use of examples with the basic pseudocode already used in section 3, expanded with the required object oriented features.

\subsection{Interfaces} \paragraph{}
An interface is used in an object oriented language in order to specify a set of methods that classes must implements. In example, we can have the following interface:
\begin{verbatim}
public interface InterfaceI {
    int commonMethod();
}
\end{verbatim}
It declares a method that will be used by classes that will implement this interface, i.e. classes A and B, that must also implement the given method. Notice that the interface only states the method signature. In this way, all classes can implement the method in a different way, and another class that uses both classes A and B, in example, class C, will use only one method (and it can also use one type for both, the one of the interface).\\
Graphically, we will obtain this structure:
% Define block styles
\tikzstyle{block} = [rectangle, draw, align=left]
\tikzstyle{line} = [draw, -latex']
\begin{center}
\scalebox{1.25}{
\begin{tikzpicture}[node distance = 1cm, auto]
    % Place nodes
    \node [] (X) {};
    \node [block, right of=X, node distance = 2cm] (A) {Class A};
    \node [below of=A, node distance = 1cm] (Y) {};
    \node [right of=Y, node distance = 1cm] (K) {};
    \node [block, right of=A, node distance = 2cm] (B) {Class B};
    \node [below of=B, node distance = 1cm] (Z) {};
    \node [block, below of=X, node distance = 2cm] (C) {Class C};
    \node [block, right of=C, node distance = 3cm] (I) {\flqq Interface\frqq\\  \ InterfaceI };
    
    % Draw edges   
    \draw[dashed]
           (A) -- (Y.north)
      node[] {};
    \draw[dashed]
           (B) -- (Z.north)
       node[] {};
    \draw[dashed]
           (Y.north) -- (Z.north)
       node[] {};
    \draw[->,>=open triangle 90,dashed]
           (K.north) -- (I)
       node[pos=0.1,anchor=south] {};
    \draw[->,-angle 90,dashed]
           (C) -- (I)
       node[anchor=east] {};
    
\end{tikzpicture} 
}
\end{center}

\subsubsection{Polymorphism} \paragraph{}
In languages similar to Java a problem appears when more than one class implement the same interface. In this case, it seems difficult to choose the right method (declared in the interface) for a given object. This circumstance is related to a principle called \emph{polymorphism}. Applied to interfaces, this concept states that the real type of an object can determine the correct method to call.\\
As for our analysis, it can be difficult to face this behaviour. Java does not solve it at compiling time, but only at execution time, by choosing the correct method using the \emph{late binding}~\cite{Horstmann:2008:BJ:1796502}. Let us take the previous example. Class C may do not want to know the correct type of an object, and use the interface type:
\begin{verbatim}
public class C {
    InterfaceI x;
    ...
    x = new A();
    x = new B();
    ...
    x.commonMethod();
}
\end{verbatim}
What is the right implementation of commonMethod that we should use? The situation is simpler that one might think. Indeed, when the CCFG algorithm executes, it expands every method. If it runs into a variable with type of an interface, we know that sooner or later it will also find the correct constructor (the interface has no constructor). If we look at the examples, when we will meet \emph{new A}() or \emph{new B}() we will expand the CCFG also for the constructor, thus knowing the correct type of the variable. At the end, when we will meet commonMethod(), we will know that it refers to the last constructor used, so we will use the implementation given by class B.

\subsubsection{Overloading}
In object oriented programming we have principle similar to the polymorphism, called constructor and method overloading. It consists into functions with same name but different parameters, that are invoked depending on the type of the parameters. Anyway, for us this is easier to face than polymorphism. Indeed, problems may only arise in the selection of the correct method during the construction of the CCFG. The CCFG algorithm must thus choose the right method by looking at its signature. 

\subsubsection{Inner Classes} \paragraph{}
Inner classes are classes declared and implemented internally to another one. As for our analysis, everything is solved during the execution of the CCFG algorithm by expanding the used methods in a way similar to normal classes. 

\subsection{Inheritance} \paragraph{}
In object oriented progrogramming language, classes can be derived from other classes, thereby inheriting fields and methods from those classes.

A class that is derived from another class is called a subclass (also a derived class, extended class, or child class). The class from which the subclass is derived is called a superclass (also a base class or a parent class).

Classes can be derived from classes that are derived from classes that are derived from classes, and so on, and ultimately derived from the topmost class, Object. Such a class is said to be descended from all the classes in the inheritance chain stretching back to Object.
The idea of inheritance is simple but powerful: When you want to create a new class and there is already a class that includes some of the code that you want, you can derive your new class from the existing class. In doing this, you can reuse the fields and methods of the existing class without having to write (and debug!) them yourself.

A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.

In our analysis, when we find a object belongs to a subclass, we know that it can be used also the method of the superclass and we have to pay attention because they can be export the confidential information.

\subsubsection{Polymorphism} \paragraph{}
Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.

It is important to know that the only possible way to access an object is through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.

The reference variable can be reassigned to other objects provided that it is not declared final. The type of the reference variable would determine the methods that it can invoke on the object.

A reference variable can refer to any object of its declared type or any subtype of its declared type. A reference variable can be declared as a class or interface type. For this reason if we don't know the real type of the object we don't know which method use if there is an overriding of a method.

In our analysis when we find a call to a method of an object we have to know if the method is a method of that object class or it is a superclass method. This information is given only when we find the definition of the object. Up to this point we do not know which method is refer the call. 

Until the information is unknown, the object is insert in the list of the unsafe variable with the possible another variable used in the call of the method. When we know the class membership then we expand the method using the CCFG and we search if the method export the variable. In the case in which the method doesn't export variables, we eliminate the variable from the list. If inside the function/procedure we find another class method, we apply this recorsively.

\subsubsection{Overriding} \paragraph{}
If a class inherits a method from its super class, then there is a chance to override the method provided that it is not marked final.

The benefit of overriding is: ability to define a behavior that's specific to the subclass type which means a subclass can implement a parent class method based on its requirement.

In object-oriented terms, overriding means to override the functionality of an existing method.

In our analysis when we find a call of a object's method override or not, we have to expand the method using CCFG and look for if the method in such way exports confidential informations. Thus when we find a method, we put inside the list of the unsafe variable the object and all the variable that are used by the method in the call. The element that will be inserted in the list will be like this:
\begin{verbatim}
   [ name_object, var_method, ...]
\end{verbatim} 
where the point can indicate that in the method can be called other method. So, there are no differences between the idea used for overriding method or not.

\subsection{Recursion}
\paragraph{}
The recursion is used when we can see that our problem can be reduced to a simpler problem that can be solved after further reduction.

Every recursion should have the following characteristics:

\begin{itemize}
\item A simple base case for which we have a solution and a return value.
\item A way of getting our problem closer to the base case. I.e. a way to chop out part of the problem to get a somewhat simpler problem.
\item A recursive call which passes the simpler problem back into the method. 
\end{itemize}

Example:
\begin{verbatim}
void myMethod(int counter)
{
if(counter == 0)
     return;
else
       {
       System.out.println(""+counter);
       myMethod(--counter);
       return;
       }
}
\end{verbatim}

In the case of recursion, our analysis works well and does not need to change, because once analyzed the code of the recursive method and seen if it is safe or not, there are no additional steps.\\
Caution, however, must be made at the time of the construction of CCFG. This is because in the case of recursion, the control flow graph of the method must occur only once, adding an edge that creates the cycle, without having to replicate the CFG for each call. Indeed, if the method is analyzed only once we do not need to repeat the analysis. In this way we avoid the possibility of incurring into an infinite replication, or otherwise having a CCFG of large dimensions that in the end would be too heavy and useless.

\subsection{Data Structures}
\paragraph{}
The data structures provided by the Java utility package are very powerful and perform a wide range of functions. These data structures consist of the following interface and classes:

\begin{itemize}
\item \textbf{Enumeration:} The Enumeration interface isn't itself a data structure, but it is very important within the context of other data structures. The Enumeration interface defines a means to retrieve successive elements from a data structure.
\item \textbf{BitSet:} The BitSet class implements a group of bits or flags that can be set and cleared individually.
\item \textbf{Vector:} The Vector class is similar to a traditional Java array, except that it can grow as necessary to accommodate new elements.
\item \textbf{Stack:} The Stack class implements a last-in-first-out (LIFO) stack of elements.
\item \textbf{Dictionary:} The Dictionary class is an abstract class that defines a data structure for mapping keys to values.
\item \textbf{Hashtable:} The Hashtable class provides a means of organizing data based on some user-defined key structure.
\item \textbf{Properties:} Properties is a subclass of Hashtable. It is used to maintain lists of values in which the key is a String and the value is also a String.
\end{itemize}

The Safeness Analysis in Data Structures should only pay attention to the methods applied to the various elements of the structure, and verify that they are safe or not, so as applies to simple variables / objects, it works in the same way for the elements of a data structure.


%\subsection{Exception Handling}
%\paragraph{}
%Blabla

%----------------------------------------------------------------------------------------
%	5. Android Environment
%----------------------------------------------------------------------------------------

\section{Android Environment}
\paragraph{}
Android is not a hardware platform, but a software environment designed specifically for mobile phone or more generally for mobile devices. In general, the platform includes an operating system based on Linux, a rich toolkit of graphical interfaces, a development environment, multimedia support and more.

\subsection{Differences between our language (simil-Java) and Android}
\paragraph{}
The runtime environment of Android platform, consists instead of a core library and a virtual machine (VM): together constitute the development platform for Android. The VM of Android is a particular version of the Java Virtual Machine (called Dalvik), specially designed and optimized to run on hardware not performing, such as mobile phones in fact.\\

User applications are written in Java and run each in its JVM. Are developed with the integration of the package provided by the Android APIs that provide for interaction with the bluetooth, location or telephone, or for the management of the graphic interface and gestures, thus creating a layer of abstraction also on components hardware. Note that the distribution is not what Java ME is performed, but a version specially developed for Dalvik: Java code is compiled and translated it into byte code, then undergoes further processing in a file format called dex. This additional step allowed us to optimize the code for the JVM, and to disengage from legal problems with Oracle.

\subsubsection{Android app peculiarities~\cite{Burnette:2010:HAI:1893143}}
\paragraph{}
Android app are different from a normal java application. First of all, they uses different libraries written specifically for the Android environment. Anyway, there are many other differences.
\begin{itemize}
\item One of the main concepts in an Android program is the Activity. An activity is responsible for the application lifecycle. Every application can define more activities, one for each phase of its execution. Every activity have 5 states: starting, running, paused, stopped, destroyed. 
\item Intents are used to describe specific actions. More formally, they are abstract descriptions of operations to be performed. They are used in the launch of an activity~\cite{website:androiddev}
\item An Android app makes large use of xml files. The most important one is the AndroidManifest. This file is located into the root of an Android project and describe all the activities performed in the app. Moreover, it also define some constraints for the application which state the permissions. In example, a permission is needed to use location related methods and libraries.\\ Other important xml files are the main.xml file in the layout directory, that describes objects containers and their behaviour on the screen, and the various variables files, like string.xml, that contains useful variables for the application.
\item R class is automatically created in each project and is used to link all the assets described in the xml files (layout, values, \ldots) to the other program classes.
\end{itemize} 

\subsection{Analysis adaptation to Android Environment}
\paragraph{}
%To be applied to an Android application to our analysis, needs some adaptation. First, given that Android apps not only use Java, but they also use the various libraries provided by Android, you have to classify such methods can be considered safe or not, and also in what situations they can still be considered safe or not.\\
%In Safeness Analysis are defined SAFE all those methods from the Android libraries that create and / or modify objects without sensitive data contained in these objects are exported. All methods that do not comply with this rule are considered UNSAFE and once collected by the SA generates a \emph{gen} step.\\
%We must, however, consider the case of applications that use sensitive data and the use was allowed on the part of the user during installation. As explained in the section above, all the activities of the app are contained inside of AndroidManifest, therefore, all the methods that can also export sensitive data, but that are contained inside of AndroidManifest must be considered SAFE, because they are part of the behavior "legal" of app. In the case where instead of our SA detects UNSAFE additional methods other than those covered by Manifest, this causes a \emph{gen} step, and thus detect any malicious behavior of the app.

%Nota 1: each object created or modified by methods of a class that belongs to the Android libraries is considered SAFE. Anyway, methods that belong to an Android library but export data will cause a \emph{gen} step.

%Nota 2: if we encounter a method that exports confidential data, but this method is not allowed by the AndroidManifest, it will not cause a \emph{gen} step.

Our analysis needs some adaptation in order to be Applied to Android applications. First, we must consider the various libraries provided by Android. In Safeness Analysis all methods that come from the Android libraries and create and/or modify objects are defined SAFE. All methods that do not comply with this rule, so methods that exports confidential data, are considered UNSAFE and they cause a \emph{gen} step when they are collected by the SA.\\
Second, we must consider applications that use confidential data where this behaviour is allowed by the AndroidManifest. As explained in the previous section, all the activities of an app are contained into that xml file. Anyway we do not need to check activity that are not present in the Manifest, because an activity like these will not be executed by the application and will possibly cause an exception (thus a developer normally delete this possibility during the testing phase).\\
The AndroidManifest also define the permissions of the application. Methods whose behaviour is not allowed by the permissions are not executed, and the application will be stopped. Anyway, this can lead to unexpected behaviour. In example, we may have an gaming application and allow internet connections in the manifest, in order to send/receive data for place ourself in an on-line rank after each match. But, this game may be a malicious application that also sends outside confidential data that we do not want to share, thanks to the permission in the manifest. Moreover, it seems that an app can anyhow access some data even if it has no permissions~\cite{website:majorvuln}~\cite{website:zeroperm}. This means that we must check all the methods allowed by the Manifest.

\subsection{Methods and data structure selection}
\paragraph{}
We still need something in order to perform the Safeness Analysis in the Android environment. Before starting the analysis execution, it is necessary to define two sets of methods:
\begin{itemize}
\item methods that \emph{exports data}
\item methods that are \emph{UNSAFE} (so methods that generate \emph{confidential data})
\end{itemize}
Notice that we refer to methods supplied by the Android libraries, not to methods defined by the developer. Indeed, the last ones are explored by the analysis itself.\\
Here we present a small subsets of methods that exports data that we will use it the final example. Anyway, in a real analysis we will need much more methods, with respect to the libraries used in the program.\\

\subsubsection{Methods that exports data}
\noindent Save a File on Internal Storage:
\begin{description}
\item[{File Class constructor + getFilesDir()}] \hfill \\It creates a new file in an internal directory of the app.
\item[{createTempFile()}] \hfill \\It creates an empty temporary file using the given prefix and suffix as part of the file name.
\item[{openFileOutput()}] \hfill \\It gets a FileOutputStream object that writes to a file in your internal directory.
\end{description}

\noindent Save a File on External Storage:
\begin{description}
\item[{getExternalStoragePublicDirectory()}] \hfill \\It saves public files on external storage, by getting a file representing the appropriate directory on the external storage.
\item[{getExternalFilesDir()}] \hfill \\It saves files that are private to the app, by passing the appropriate directory.
\end{description}

\noindent Sending HTTP Post data:
\begin{description}
\item[{HttpPost Class constructor + setEntity()}] \hfill \\The combination of these two methods allow to send data through an http post.
\end{description}

%\noindent \textbf{}
%\begin{description}
%\item[{}] \hfill \\
%\item[{}] \hfill \\
%\end{description}

\subsubsection{Methods that generate confidential data}
\noindent Retrieving GPS location:
\begin{description}
\item[{requestLocationUpdates()}] \hfill \\Method of the LocationManager class, it registers for location updates by using an intent or a thread and some criteria or a provider.
\item[{getLatitude()}] \hfill \\Method of the Location class, it gets the latitude, in degrees.
\item[{getLongitude()}] \hfill \\Method of the Location class, it gets the longitude, in degrees.
\end{description}

\noindent Retrieving a contact from address book:
\begin{description}
\item[{getContentResolver()}] \hfill \\Return a ContentResolver instance. If applied to ContactsContract it is capable of returning contact data.
\end{description}

Anyway, notice that confidential data may also be created by methods developed with the application.

%\noindent \textbf{}
%\begin{description}
%\item[{}] \hfill \\
%\item[{}] \hfill \\
%\end{description}


\subsection{Android App Example}
\paragraph{}
This section is devoted to an example applied to a real Android application. This application has been created and tested specifically for this project with Eclipse IDE.

\subsubsection{Code}
Please refer to Appendix A (p.~\pageref{app:appendixA}) for the code of the example.

\subsubsection{Description}
We implemented a simple application that show the istantaneous position of the device. The position is given by the latitude and the longitude. When the position changes, it is automatically updated. Now we explain how works this app.

The first screen that we find is a simple screen with a button that when we press it, it redirect us to the second screen that shows the current location of the device. The localization is done implementing the LocationListener interface and the data of longitude and latitude are given from the method getLongitude() and getLatitude(), respectively. The aim of the implemented class is to show the current position of the device, so when the device change its locantion the values of longitude and latitude are updated automatically. 

The confidantial datas are contained in the variable longitude and latitude, then we have to pay attention if they are exported in some ways. Obviously if they are only modified and not exported in some way, the application is classified as 'safe'.

The expected result of the analysis is that there are no unsafe variable because there are no method that export the confidential data, namely the value of the longitude and the latitude. During the analysis in fact some variables are inserted into the list of unsafe variables as "possible unsafe variable" but in the end, all of them are deleted from it. 

The first step of our analysis is done analysing the file AVPtest which contains the main class. Inside it we see that it calls a method that create the activity associated to GeoLocation class, so our attention is focused on this class. Thus We expand this class and analyze it.

In the GeoLocation class, we can see that there are a new call to the costructor LocationUpdateHandler() using the method requestLocationUpdates(...). With that, the program has created a listener that, every time that the position changes, it starts the function LocationUpdateHandler() that use the implemented function onLocationChanged(...), for this reason we expand this function. Inside it we can see that there are no method which export confidential data. Using this information we can eliminate the variable associated to the method onLocationChanged(...) and requestLocationUpdates(...) from the list of possible unsafe variable.

In the end of our analysis we obtain the expected result.

Instead, if we are interested to an unsafe application, we have to modify the point in the application in which the position is updated. In this point we can insert a simple command that send the current position of the device to a malicious user or save its position in a file and sends it later (we can see some examples of method that save the information in a file and share it with other users in the section 'Methods and data structure selection').

\subsubsection{CCFG}

\subsubsection{Tables}
%----------------------------------------------------------------------------------------
%	6. Conclusions
%----------------------------------------------------------------------------------------

\section{Conclusions}
\paragraph{}
Blabla

\subsection{Future developments}
\paragraph{}
Blabla

%----------------------------------------------------------------------------------------
%	NOTES AND BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

{\footnotesize \bibliographystyle{acm}
\bibliography{biblio}
}

\theendnotes

%column break
\vfill
\break

\onecolumn
\appendix
\label{app:appendixA}
\lstset{language=Java}  
\section{Appendix: example code}

\subsection{Class AVPtest.java}
\begin{lstlisting}
package com.examples.avptest;

import android.app.Activity;
import android.os.Bundle;
import android.content.Intent;
import android.view.View;
import android.view.View.OnClickListener;

public class AVPtest extends Activity implements OnClickListener {

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		setContentView(R.layout.main);
		
		View getlocButton = findViewById(R.id.getloc_button);
		getlocButton.setOnClickListener(this);
	}

	@Override
	public void onClick(View v) {
		switch (v.getId()) {
		case R.id.getloc_button:
			Intent i = new Intent(this, GetLocation.class);
			startActivity(i);
			break;
		// More buttons
		}
	}

}
\end{lstlisting}

\subsection{Class GetLocation.java}
\begin{lstlisting}
package com.examples.avptest;

import android.app.Activity;
import android.content.Context;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.widget.TextView;

public class GetLocation extends Activity {

	private LocationManager locationManager;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
		locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0,
				0, new LocationUpdateHandler());

		setContentView(R.layout.getloc);
	}

	public class LocationUpdateHandler implements LocationListener {

		@Override
		public void onLocationChanged(Location loc) {
			int lat = (int) (loc.getLatitude() * 1E6);
			int lng = (int) (loc.getLongitude() * 1E6);
			
			TextView myLocationText = (TextView) findViewById(R.id.getloc_content);
			myLocationText.setText("Latitude: " + lat + "\n" + "Longitude: "
					+ lng);
		}

		@Override
		public void onProviderDisabled(String provider) {
		}

		@Override
		public void onProviderEnabled(String provider) {
		}

		@Override
		public void onStatusChanged(String provider, int status, Bundle extras) {
		}
	}
}

\end{lstlisting}

\lstset{language=XML}  
\subsection{AndroidManifest.xml}
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	package="com.examples.avptest" android:versionCode="1"
	android:versionName="1.0">
	
     <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="10" />
    
	<uses-permission xmlns:android="http://schemas.android.com/apk/res/android"
		android:name="android.permission.ACCESS_FINE_LOCATION" />
	<uses-permission xmlns:android="http://schemas.android.com/apk/res/android"
		android:name="android.permission.ACCESS_MOCK_LOCATION" />

	<application android:icon="@drawable/icon" android:label="@string/app_name">
		<activity android:name=".AVPtest" android:label="@string/app_name">
			<intent-filter>
				<action android:name="android.intent.action.MAIN" />

				<category android:name="android.intent.category.LAUNCHER" />
			</intent-filter>
		</activity>
		<activity android:name=".GetLocation" android:label="@string/getloc_title" />
	</application>

</manifest>
\end{lstlisting}

\label{app:appendixB}
\section{Appendix: example CCFG}
\begin{center}
% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define block styles
\tikzstyle{block} = [rectangle, draw, align=left]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{every node}=[font=\footnotesize]

\hspace*{-7mm}\scalebox{0.85}{
\begin{tikzpicture}[node distance = 1cm, auto][every node/.style={inner sep=0,outer sep=0}]

    % AVPTest nodes
    \node [block] (AVP1) {void onCreate(Bundle savedInstanceState)  \{ };
    \node [block, below of=AVP1] (AVP2) {super.onCreate(savedInstanceState)};
    \node [block, below of=AVP2] (AVP3) {setContentView(R.layout.main);};
    \node [block, below of=AVP3](AVP4) {View getlocButton = findViewById(R.id.getloc\_button);};
    \node [block, below of=AVP4] (AVP5) {getlocButton.setOnClickListener(this);};
	\node [block, below of=AVP5, node distance=4em] (AVP6) {public void onClick(View v) \{ };
	\node [block, below of=AVP6] (AVP7) {switch (v.getId())  \{ };
    \node [block, below of=AVP7] (AVP8) {case R.id.getloc\_button:};
    \node [block, below of=AVP8](AVP9) {Intent i = new Intent(this, GetLocation.class);};
    \node [block, below of=AVP9] (AVP10) {startActivity(i);};
    \node [block, below of=AVP10] (AVP11) {break; \}\} };
    
    % GetLocation class nodes
    \node [block, right of=AVP1, node distance=10cm] (GL1) {private LocationManager locationManager;};
    \node [block, below of=GL1, node distance=4em] (GL2) {protected void onCreate(Bundle savedInstanceState)  \{ };
    \node [block, below of=GL2] (GL3) {super.onCreate(savedInstanceState);};
    \node [block, below of=GL3] (GL4) {locationManager = (LocationManager) getSystemService(Context.LOCATION\_SERVICE);};
    \node [block, below of=GL4] (GL5) {locationManager.requestLocationUpdates(LocationManager.GPS\_PROVIDER, 0,\\ \qquad 0, new LocationUpdateHandler()); };
    \node [block, below of=GL5] (GL6) {setContentView(R.layout.getloc); \} };

    % LocationUpdateHandler class nodes
    \node [block, below of=GL5, node distance=8em] (LUH1) {public void onLocationChanged(Location loc) \{ };
    \node [block, below of=LUH1] (LUH2) {int lat = (int) (loc.getLatitude() * 1E6); };
    \node [block, below of=LUH2] (LUH3) {int lng = (int) (loc.getLongitude() * 1E6);};
	\node [block, below of=LUH3] (LUH4) {TextView myLocationText = (TextView) findViewById(R.id.getloc\_content); };
	\node [block, below of=LUH4] (LUH5) {myLocationText.setText("Latitude: " + lat + "$\textbackslash\text{n}$" + "Longitude: "+ lng); \} };

    %background shapes 
    \begin{pgfonlayer}{background}
        %AVPTest Class
        \path (AVP4.west |- AVP1.north)+(-0.2,0.2) node (a) {};
        \path (AVP11.south -| AVP4.east)+(0.2,-0.4) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
        %GetLocation Class
        \path (GL4.west |- GL1.north)+(-0.2,0.2) node (a) {};
        \path (LUH5.south -| GL4.east)+(0.2,-1) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
        %LocationUpdateHandler Class
        \path (LUH4.west |- LUH1.north)+(-0.2,0.2) node (a) {};
        \path (LUH5.south -| LUH4.east)+(0.2,-0.4) node (b) {};
        \path[rounded corners, draw=black!100, dashed] (a) rectangle (b);
    \end{pgfonlayer}  
        
    %class labels
    \path (AVP11.south)+(-2.3,-0.6) node (AVPTest) {\textbf{AVPTest Class}};
    \path (LUH5.south)+(-4,-1.2) node (GetLocation) {\textbf{GetLocation Class}};
    \path (LUH5.south)+(-2.5,-0.6) node (LocationUpdateHandler) {\textbf{LocationUpdateHandler Class}};
    
    % Draw arrows between blocks internal to classes
    \path [line] (AVP1) -- (AVP2);
    \path [line] (AVP2) -- (AVP3);
    \path [line] (AVP3) -- (AVP4);  
    \path [line] (AVP4) -- (AVP5);  
    \path [line] (AVP6) -- (AVP7);  
    \path [line] (AVP7) -- (AVP8);  
    \path [line] (AVP8) -- (AVP9);  
    \path [line] (AVP9) -- (AVP10);  
    \path [line] (AVP10) -- (AVP11);
    \path [line] (GL2) -- (GL3);      
    \path [line] (GL3) -- (GL4);
    \path [line] (GL4) -- (GL5);
    \path [line] (GL5) -- (GL6);
    \path [line] (LUH1) -- (LUH2);
    \path [line] (LUH2) -- (LUH3);
    \path [line] (LUH3) -- (LUH4);
    \path [line] (LUH4) -- (LUH5);
    
    %curved arrows
    \begin{scope}[looseness=1.8]
        \path [draw, ->] (AVP9) edge[out=0,in=180,->]  node [left] {} (GL2);
        \path [draw, ->] (GL5) edge[out=0,in=0,->]  node [right] {} (LUH1);
        \path [draw, ->, dashed] (AVP5) edge[out=180,in=180,->]  node [left] {} (AVP6);
    \end{scope} 
     
\end{tikzpicture}
}
\end{center}
\label{app:appendixC}
\section{Appendix: example tables}
\begin{center}
\begin{small}
\begin{tabular}{|l|c|*{2}{p{7cm}|}}
  \hline
  n & classname & gen & kill  \\
  \hline 
  5 & AVPtest & \{geoLocButton[this], 5, AVPtest\} & \\
  11 & AVPtest &  & \\
  10 & AVPtest &  & \\
  9 & AVPtest & \{i[this], 9, AVPtest\} & \\
  6 & GetLocation &  & \\
  5 & GetLocation & \{LocationManager[new LocationUpdateHandler()], 5, GetLocation\} & \\
  5 & LocationUpd &  & \\
  4 & LocationUpd &  & \\
  3 & LocationUpd &  & \\
  2 & LocationUpd &  & \\
  1 & LocationUpd &  & \\
  4 & GetLocation & & \{LocationManager[new LocationUpdateHandler()], 5, GetLocation\} \\
  3 & GetLocation & & \\
  2 & GetLocation & & \\
  1 & GetLocation & & \\
  8 & AVPtest &  & \{i[this], 9, AVPtest\} \\
  7 & AVPtest &  & \\
  6 & AVPtest &  & \\
  4 & AVPtest &  & \{geoLocButton[this], 5, AVPtest\} \\
  3 & AVPtest &  & \\
  2 & AVPtest &  & \\
  1 & AVPtest &  & \\  
  \hline
\end{tabular}
\\
\begin{tabular}{|l|c|*{2}{p{7cm}|}}
  \hline
  n & classname & entry & exit  \\
  \hline 
  5 & AVPtest & \{geoLocButton[this]\} & \{geoLocButton[this]\} \\
  11 & AVPtest & \{geoLocButton[this]\} & \{geoLocButton[this]\} \\
  10 & AVPtest & \{geoLocButton[this]\} & \{geoLocButton[this]\} \\
  9 & AVPtest & \{geoLocButton[this,i[this]]\} & \{geoLocButton[this,i[this]]\} \\
  6 & GetLocation & \{geoLocButton[this,i[this]]\} & \{geoLocButton[this,i[this]]\} \\
  5 & GetLocation & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} \\
  5 & LocationUpd & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} \\
  4 & LocationUpd & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} \\
  3 & LocationUpd & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} \\
  2 & LocationUpd & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} \\
  1 & LocationUpd & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} \\
  4 & GetLocation & \{geoLocButton[this,i[this,LocationManager[new LocationUpdateHandler()]]\} & \{geoLocButton[this,i[this]]\} \\
  3 & GetLocation & \{geoLocButton[this,i[this]]\} & \{geoLocButton[this,i[this]]\} \\
  2 & GetLocation & \{geoLocButton[this,i[this]]\} & \{geoLocButton[this,i[this]]\} \\
  1 & GetLocation & \{geoLocButton[this,i[this]]\} & \{geoLocButton[this,i[this]]\} \\
  8 & AVPtest & \{geoLocButton[this,i[this]]\} & \{geoLocButton[this]\} \\
  7 & AVPtest & \{geoLocButton[this]\} & \{geoLocButton[this]\} \\
  6 & AVPtest & \{geoLocButton[this]\} & \{geoLocButton[this]\} \\
  4 & AVPtest & \{geoLocButton[this]\} &  \\
  3 & AVPtest &  & \\
  2 & AVPtest &  & \\
  1 & AVPtest &  & \\
  \hline
\end{tabular}
\end{small}
\end{center}

%----------------------------------------------------------------------------------------
%	END OF DOCUMENT
%----------------------------------------------------------------------------------------

\end{document}







